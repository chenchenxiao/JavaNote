AOP原理是通过动态代理来实现的
如果被代理的目标对象实现了至少一个接口，则会使用JDK动态代理，若该目标对象没有实现任何接口，则使用Cglib代理
    JDK动态代理：
        代理对象要实现InvocationHandler接口，要实现invoke方法，方法的调用是转发到invoke方法上的；方法要传入代理的对象，需要代理的方法和方法的参数列表
        还需要有一个代理类：调用newInstance()方法返回一个代理对象，该方法需要传入三个参数
        第一个参数表示用哪个ClassLoader来加载代理对象，第二个表示真实对象所实行的接口，表示我要代理的该真实对象，第三个是handler，就是代理类
        第二个参数表示给代理对象提供了一组什么接口，可以将代理对象强制类型转为这组接口中的任意一个
    优点：
        动态代理类的字节码在程序运行时通过反射机制动态生成
    缺点：
        只能代理实现了接口的类，而没实现接口的类就是无法实现JDK动态代理
    Cglib代理：
        这种代理方式是动态生成一个要代理类的子类，子类要重写代理类的所有非final方法，在子类中使用方法拦截的技术拦截所有父类方法的调用，顺势植入横切逻辑，比java反射的JDK动态代理要快。
        通过使用字节码处理框架ASM，来转换字节码并生成新的类。
        要实现一个MethodInceptor接口，方法的调用会转发到该接口的inceptor方法上，与JDK代理类似