###并发编程的艺术笔记
####基础知识

    java内存模型：定义了共享内存系统中对多线程程序读写行为的规范。

######什么是上下文切换？
    cpu通过时间片算法来循环执行任务，当前任务执行完一个时间片后会切换到下一个任务；
    在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以加载到这个任务的状态；任务从保存到再加载的过程就是一次上下文切换。
######如何减少上下文切换？
    1. 无锁并发编程：   
    2. CAS算法，Java的Atomic包使用CAS算法来更新数据，无需加锁。
    3. 使用最少线程，避免创建不需要的线程。
    4. 协程:在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换  。        
######避免死锁的几个常见方法
    1. 避免一个线程同时获取多个锁
    2. 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
    3. 尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制。
    4. 对于数据库锁，加锁和解锁必须在同一个数据库连接里，否则会出现解锁失败的情况。

####Java并发机制的底层实现原理
######volatile
    有volatile修饰的变量在进行写操作时在CPU中会调用Lock指令，Lock在多核处理器下发生了两件事情
        1、将当前处理器缓存行的数据 写回到系统内存中。
        2、这个写回内存的操作会使其他CPU里缓存了该内存地址的数据无效
######synchronized 
    三种表现形式：
        1、对于普通同步方法，锁是当前实例对象
        2、对于静态同步方法，锁是当前类的Class对象
        3、对于同步方法块，锁是Scnchronized括号里配置的对象
    每个对象都有一个monitor与之关联，当一个monitor被持有后，它将处于锁定状态，synchronized就是通过获取monitor来实现同步的
    
    对象头：
         Mark World: 存储对象的hashCode、分代年龄和锁信息等
         Class Metedate Address: 存储对象类型数据的指针，JVM通过这个指针确定该对象的数据是哪个类的数据
         
    四种锁状态：
        1.无锁
        2.偏向锁： 当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储当前获取到锁的线程的ID，
                  下次再获取锁时只要检查对象头的Mark Word里存储的ThreadID是否和当前线程ID一样即可
                    偏向锁适用于无竞争的情况下，减少了申请锁的操作，无需再次触发同步。
                  当有两个线程争夺资源时，无论怎样都会升级会轻量级锁
        3.轻量级锁： 当有其他线程来竞争锁时，持有偏向锁的线程会被挂起，JVM会尝试消除它身上的偏向锁，将锁升级为轻量级锁
                     轻量级锁的本意是为减少多线程进入互斥的状态，通过CAS来避免进入开销较大的互斥操作
                     所适应的场景是线程交替执行同步块的场合
                     当自旋超过一定次数，或者一个线程持有锁，一个自旋，又有一个来争夺时，会升级为重量级锁
                     
                     .0
        4.重量级锁：同一时间多线程访问同一个锁时，就会导致轻量级锁升级为重量级锁
         
        * synchronized是可以升级的，随着竞争，锁会逐渐升级，但不会降级。
                     
######原子操作
    在Java中可以通过锁和循环CAS来实现原子操作
    CAS的三大问题：
        1. ABA问题，可以通过追加版本号来解决，也可以通过使用AtomicStampedReference来解决
        2. 循环时间长开销大， CPU的pasue指令有两个作用：1）延迟流水线执行指令，使CPU不会消耗过多的执行资源；2）避免在退出循环的时候因内存顺序冲突而引起CPU流水线被清空，从而提高CPU的执行效率
           -XX:PreBlockSpin可以设置自旋的次数，默认是10次
        3. 只能保证一个共享变量的原子操作，可以使用锁或者是把多个变量合成一个共享变量的方式来解决                

####Java内存模型
    线程间的通信机制：
                    1.共享内存（Java的并发采用的就是这种机制）  
                    2.消息传递
    Java编译器在生成指令序列的适当位置插入内存屏障指令来保证内存可见性
         LoadLoad：    Load1； LoadLoad； Load2        确保Load1数据的装载先于Load2及后续装载指令的装载
         StoreStore：  Store1；StoreStore； Store2     确保Store1数据对于其他处理器可见（刷新到内存）先于Store2及后续存储指令的存储
         LoadStore：   Load1；LoadStore； Store2       确保Load1数据装载先于Store2及后续的存储指令刷新到内存
         StoreLoad：   Store1；StoreLoad；Load2        确保Store1数据对其他处理器变得可见（指刷新到内存）先于Load2及后续装载指令的装载，
                                                      该指令会使该屏障之前的所有内存访问指令完成后，才知晓该屏障之后的内存访问指令
         在每个volatile写操作的前面插入StoreStore，在后面插入StoreLoad。
         在每个volatile读操作的前面插入LoadStore，在后面插入LoadLoad                                         
                                                  
    happens-before原则
        程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作
        监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁
        volatile变量规则：对于一个volatile域的写，happens-before于任意后续对这个volatile域的读
        传递性：如果A happens-before B，且B happens-before C，那么A happens-before C  
         
    as-if-serial语义
        不管怎么重排序，单线程程序执行的结果不能被改变，编译器和处理器不会对存在数据依赖关系的操作做重排序                       
    
####volatile的内存语义
    volatile特性：
                 可见性：对一个volatile变量的读，总是能看到对这个volatile变量最后的写入
                 原子性：对任意单个volatile变量的读写具有原子性，但类似于++这种复合操作没有原子性    
    写语义：当写一个volatile变量时，JVM会把该线程对于的本地内存中的共享变量值刷新到主内存中
    读语义：当读一个volatile变量时，JVM会把该线程对应的本地内存置为无效，该线程接下来将从主内存中读取共享变量
    CAS操作具有volatile的读写语义

####final域的内存语义
    1) 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作间不能重排序
    2) 初次读一个包含final域的对象的引用，与随后初次读这个final域，两个操作之间不能重排序
    为了确保引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了，需要保证在构造函数内部不能让这个构造对象的引用为其他线程可见
    
    
###并发编程的基础
    使用多线程的原因：
        1.更多的处理器核心
        2.更快的响应时间
        3.更好的编程模型
        
    构造线程：
        线程在构造时是由其父线程来进行空间分配的，继承了父线程是否为Daemon，优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，还会分配一个唯一ID来识别该线程
    
    过期方法：
        supsend调用后，线程不会释放以及占有的资源，而是占着资源进入睡眠状态，这样容易引发死锁问题，
        stop方法在终结一个线程时不保证线程的资源正常释放                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
    
    while(value != result) {
        Thread.sleep(1000);
    }
    doSomething();
    上述代码存在的问题
        1) 难以确保及时性：在睡眠时基本不消耗处理器资源，但是如果睡得过久，就不能发现条件已经变化，也就是及时性难以保证
        2) 难以降低开销：如果降低睡眠的时间，能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费
        使用等待/通知机制可以解决这些问题
        
####AQS
    同步器提供的方法基本上分为3类：
        1.独占式获取与释放同步状态
        2.共享式获取与释放同步状态
        3.查询同步队列中的等待线程情况
        
    可重写的方法：
        tryAcquire  独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后进行CAS设置同步状态
        tryRelease  独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态
        tryAcquireShared 共享式获取同步状态，返回大于等于0的值，表示获取成功，反之失败
        tryRealeaseShared 共享式释放同步状态
        isHeldExclusively 当前同步器释放在独占模型下被线程占用，一般该方法表示是否被当前线程占用
        
    排他锁： 在加锁时会将状态值加一，释放锁时会减一，直到状态值为0时才会真正释放锁，也就是只有加锁和释放锁的次数一致时才会将锁的Owner设置为空   
        
######AQS的实现
    1 同步队列
    
        AQS依赖内部的同步队列(一个FIFO双向队列)来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点并将其加入同步队列，
        同时会阻塞线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态
        
        节点的属性
            int waitStatus
            等待状态，包含以下状态
                ① CANCELLED，值为1，由于在同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待，节点进入该状态将不会变化
                ② SIGNAL 值为-1，后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行
                ③ CONDITION 值为-2，节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal方法后，该节点将会从等待队列中转移到同步队列中，加入到对同步状态的获取中
                ④ PROPAGATE 值为-3，表示下一次共享式同步状态获取将会无条件地被传播下去  在共享模式中，该状态标识结点的线程处于可运行状态。
                ⑤ INITAL 值为0，初始状态
            Node prev
                前驱节点，当节点被加入同步队列时被设置
            Node next
                后继节点
            Node nextWaiter
                等待队列中的后继节点，如果当前节点是共享的，那么这个字段将是一个SHARED常量，也就说节点类型(独占和共享)和等待队列中的后继节点共用同一个字段
            Thread thread
                获取同步状态的线程
        
        同步器拥有首节点和尾节点，没有成功获取同步状态的线程将会成为节点加入该队列的尾部，同步器提供了一个基于CAS设置尾节点的方法：CompareAndSetTail()，
        需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联
        同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态时成功将自己设置为首节点
        同步器是使用一个int变量来表示状态从而实现锁功能的
        
    2 独占式同步状态获取与释放
        通过调用同步器的acquire()方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出
        在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列(或停止自旋)点条件是前驱节点为头节点且成功获取了同步状态。
        在释放同步状态时，同步器调用tryRelease方法释放同步状态，然后唤醒头结点的后继节点
        
    3 共享式同步状态获取与释放
        共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态
    
    4 独占式超时获取同步状态
        通过调用同步器的doAcquireNanos方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false
        
    5 ReentrantLock,CountDownLatch,Semaphore等并发工具都是通过AQS来实现的，
      CyclicBarrier在内部使用的是一个ReentrantLock对象    
    
####重入锁
    支持重进入的锁，能够支持一个线程对资源的重复加锁，支持获取锁时的公平和非公平性选择
    
    重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性需要解决下面的两个问题
    1. 线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是则再次成功获取。
    2. 锁的最终释放。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数为0时表示锁已经成功释放
        
    公平锁与非公平锁的区别
        公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO
        公平锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换，非公平锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了更大的吞吐量
    
####读写锁
    读写锁维护了一对锁，一个读锁和一对写锁，通过分离读锁和写锁，使得并发性比一般的排他锁有了很大提升
    
    如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程(线程安全，靠CAS保证)增加读状态，成功获取读锁
    
######锁降级
    锁降级指的是把持有(当前拥有的)写锁，再获取到读锁，随后释放(先前拥有的)写锁的过程
    
####Condition
    Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。Condition对象是由Lock对象创建出来的。
    主要包括了：等待队列，等待和通知。
    
    等待队列：
        等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，
        如果一个线程调用了Condition.await方法，那么该线程会释放锁，以该线程构造成节点加入等待队列并进入等待队列。该节点复用了同步器中节点的定义。
        
    等待(await)：
        调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列，然后释放同步状态，
        唤醒同步队列中的后继节点，然后当前线程会进入等待状态。当等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态，
        
    唤醒(signal)：
        调用该方法，将会唤醒在等待队列中等待时间最长的节点(首节点)，在唤醒节点之前，会将节点移到同步队列中
        被唤醒后的线程，将从await方法中的while循环中退出，进而调用同步器的acquireQueued方法加入到获取同步状态的竞争中。
        成功获取同步状态(或者说锁)之后，被唤醒的线程将从先前调用的await方法返回，此时该线程已经成功获取了锁。
        signalAll方法相对于signal来说就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程
    
####阻塞队列
    ArrayBlockingQueue:由数组结构组成的有界阻塞队列
    LinkedBlockingQueue:由链表结构组成的有界阻塞队列
    PriorityBlockingQueue:支持优先级排序的无界阻塞队列
    DelayQueue:使用优先级队列实现的无界阻塞队列
    Synchronous:不存储元素的阻塞队列(只能有一个元素)
    LinkedTransferQueue:由链表结构组成的无界阻塞队列
    LinkedBlockingQueue:由链表结构组成的双向阻塞队列

####原子操作类
    AtomicBoolen：原子更新布尔类型
    AtomicInteger：原子更新整型
    AtomicReference：原子更新引用类型
    其他类似。。。

####并发工具类
    CountDownLatch
        接收一个int类型的参数做计数器，当计数器减为0时表示所有线程都执行完毕
        允许多个或一个线程等待其他线程完成操作，相当于A要等BCD全部执行完毕才能执行
    
    CaclicBarrier
        接收一个参数表示屏障拦截的线程数量，调用await表示我已经到达了屏障
        让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障。相当于B要等A执行完才会继续执行，CD同理
    
    Semaphore
        用来控制同时访问特定资源的线程数量，通过协调各个线程以保证合理的使用公共资源，用于做流量控制
        给定一个参数表示同时能访问资源的线程数量。
        相当于分发许可证，只有拿到许可证才可以执行，没拿到就不可以
    
    Exchanger
        用于线程间协作的工具类，用于进行线程间的数据交换，提供一个同步点，两个线程在这个同步点可交换彼此的数据
        如果两个线程有一个没有执行exchanger方法，则会一直等待，可以设置等待时长
    
####线程池
    使用线程池的优点：
        1. 降低资源消耗。通过反复利用已创建的线程来降低线程创建和销毁造成的消耗。
        2. 提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。
        3. 提高线程的可管理性，使用线程池可以避免无限制地创建，能提高系统的稳定性，使用线程池可以进行统一分配，调优和监控
        
    线程池的处理流程
        1. 线程池判断核心线程池里的线程是否都在执行任务，如果不是就创建一个新的工作线程来执行任务。否则进入下个流程
        2. 线程池判断工作队列是否已满。如果没满就将新提交的任务存储在这个工作队列，否则进入下个流程
        3. 线程池判断线程池的线程是否都处于工作状态。如果没有则创建一个新的工作线程执行任务，否则交给饱和策略来处理这个任务
        
    execute和submit
        前者用于提交不需要返回结果的任务，后者用于提交需要返回结果的任务，返回的是一个Future对象
    
    ThreadPoolExecutor： 是线程池的核心，用来执行被提交的任务
        四个主要组件：
            corePoolSize：线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；
                      如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。
            maxinumPool：线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maxinumPoolSize；
            BlockingQueue：用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口
            keepAliveTime：线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用；
            RejectExecutionHandler：当ThreadExecutor已经关闭或已经饱和时（达到了最大线程池大小且工作队列已满），execute方法将要调用的Handler
          
            核心线程和普通线程的区别在于核心线程在闲置时间过后不会被销毁，而普通线程会。
            是通过阻塞队列的take方法和poll方法来实现的，执行完任务后会判断当前活动线程数，
            如果大于核心线程数，执行poll方法，从缓存队列中取任务，最长等待时间过后仍然取不到会返回null，此时runWorker方法中的while循环会退出，对应的线程也就要销毁了。
            如果小于核心线程数，执行take方法，从缓存队列中取任务，若队列为空，进入阻塞状态，直到取到任务为止。
        
        线程池五个状态  
            RUNNING：正常的状态，接收新的任务，处理等待队列中的任务   -1
            SHUTDOWN:不接受新的任务提交，但是会继续处理等待队列中的任务  0
            STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程
            TIDYING：所有的任务都销毁了，workCount为0，线程池的状态在转换为TIDYING时，会执行terminated()方法
            TERMINATED：terminated方法结束后，线程池的状态就会变成这个
            当等于0时不能提交任务，大于0的会连正在执行的任务都要中断
           
            RUNNING -> SHUTDOWN：当调用了 shutdown() 后，会发生这个状态转换，这也是最重要的
            (RUNNING or SHUTDOWN) -> STOP：当调用 shutdownNow() 后，会发生这个状态转换，这下要清楚 shutDown() 和 shutDownNow() 的区别了
            SHUTDOWN -> TIDYING：当任务队列和线程池都清空后，会由 SHUTDOWN 转换为 TIDYING
            STOP -> TIDYING：当任务队列清空后，发生这个转换
            TIDYING -> TERMINATED：这个前面说了，当 terminated() 方法结束后

            
        FixedThreadPool
            使用的是无界队列LinkedBlockingQueue存放任务
            开辟指定数目的线程，如果要执行的线程数大于开辟的数目，则会将线程放入LinkedBlockQueue，当大于Integer的最大值时会执行拒绝策略
            分批执行线程，而且不会销毁线程，因为执行的数目不可能大于开辟的数目
            
        SingleThreadPool
            相当于使用单个线程的FixedThreadPool，也是使用LinkedBlockingQueue来存放任务
            当任务完成时，会在一个无限循环中反复从LinkedBlockingQueue获取任务执行
        
        CacheThreadPool
            是无界的，使用没有容量的SynchronousQueue作为线程池的工作队列，适用于生命周期较短的任务
    
    SingleThreadScheduledExecutor
       将定时任务与线程池功能结合使用。可以周期性的执行任务
       
       