# mysql基础

## 数据库连接池

连接池用于创建和管理数据库连接的缓冲池技术，缓冲池中的连接可以被任何需要他们的线程使用。当一个线程需要用JDBC对一个数据库操作时，将从池中请求一个连接。当这个连接使用完毕后，将返回到连接池中，等待为其他的线程服务。 连接池的主要优点有以下三个方面。

第一、**减少连接创建时**间。连接池中的连接是已准备好的、可重复使用的，获取后可以直接访问数据库，因此减少了连接创建的次数和时间。

第二、**简化的编程模式**。当使用连接池时，每一个单独的线程能够像创建一个自己的JDBC连接一样操作，允许用户直接使用JDBC编程技术。

第三、**控制资源的使用**。如果不使用连接池，每次访问数据库都需要创建一个连接，这样系统的稳定性受系统连接需求影响很大，很容易产生资源浪费和高负载异常。连接池能够使性能最大化，将资源利用控制在一定的水平之下。连接池能控制池中的连接数量，增强了系统在大量用户应用时的稳定性。

### Q：如果连接池中的连接都被使用完了呢？

如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。 当客户释放数据库连接时，**先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。**

————————————————————————————————————————————

连接池的工作原理主要由三部分组成，分别为**连接池的建立、连接池中连接的使用管理、连接池的关闭**。

第一、连接池的建立。一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销。Java中提供了很多容器类可以方便的构建连接池，例如Vector、Stack等。

第二、连接池的管理。连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。其管理策略是：

当客户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数**是否已经达到最大连接数**，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。 当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。

该策略保证了数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。

第三、连接池的关闭。当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反。

### mysql性能调优（包含sql优化）

1.查看慢查询日志，定位执行效率差的SQL

2.需要知道该sql的执行，使用explain。

EXPLAIN命令是查看优化器如何决定执行查询的主要方法。

#### 临时表优化：

（临时表分内存临时表和磁盘临时表，如果是巨大的临时表，内存装不下，就会拷贝到磁盘）

如果表的设计已经确定，修改比较困难，那么也可以通过优化SQL语句来减少临时表的大小，以提升SQL执行效率。
常见的**优化SQL语句**方法如下：
1）拆分SQL语句
临时表主要是用于排序和分组，很多业务都是要求排序后再取出详细的分页数据，**这种情况下可以将排序和取出详细数据拆分成不同的SQL，以降低排序或分组时临时表的大小**，提升排序和分组的效率，我们的案例就是采用这种方法。
2）优化业务，去掉排序分组等操作
有时候业务其实并不需要排序或分组，仅仅是为了好看或者阅读方便而进行了排序，例如数据导出、数据查询等操作，这种情况下去掉排序和分组对业务也没有多大影响。

**设计优化**

使用临时表一般都意味着性能比较低，特别是使用磁盘临时表，性能更慢，因此我们**在实际应用中应该尽量避免临时表的使用**。 常见的避免临时表的方法有：
1）创建索引：**在ORDER BY或者GROUP BY的列上创建索引**；
2）**分拆很长的列**：一般情况下，TEXT、BLOB，大于512字节的字符串，基本上都是为了显示信息，而不会用于查询条件， 因此表设计的时候，应该将这些列独立到另外一张表。

- **如何判断使用了临时表？**

使用explain查看执行计划，Extra列看到Using temporary就意味着使用了临时表。

### 分表

目的：减少数据查询所需要的时间，提高数据库的吞吐量。

只能够对数据库的读进行扩展，而对数据库的写入操作还是集中在Master上，并且单个Master挂载的Slave也不可能无限制多，Slave的数量受到Master能力和负载的限制。

**对于访问极为频繁且数据量巨大的单表来说，我们首先要做的就是减少单表的记录条数，以便减少数据查询所需要的时间，提高数据库的吞吐，这就是所谓的分表**

对于互联网企业来说，大部分数据都是与用户关联的，因此，用户id是最常用的分表字段。因为大部分查询都需要带上用户id，这样既不影响查询，又能够使数据较为均衡地分布到各个表中

### 分库

目的：提高数据库写入能力

分表能够解决单表数据量过大带来的查询效率下降的问题，但是，却无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库master服务器无法承载写操作压力时，不管如何扩展slave服务器，此时都没有意义了。

Q：分表和master-slave有什么关系？

一张表和两张表有什么区别？查询速度变快，然后呢？和这个主从架构有什么关系吗，这个架构带来的好处是可以分散读压力，可是不分表，读压力就？分表并不会增加数据库实例不是吗？



### 分库分表带来的坏处

ACID解决方法

**分布式事务问题**：使用两阶段提交协议

**水平切分递增ID被破坏**：多机sequence问题

解决方法：从连续性和唯一性考虑，考虑唯一性的话，可以使用uuid，根据自己的业务情况使用各种种子（不同纬度的表示，例如IP，MAC，机器名，时间，本机计数器等因素）来生成唯一的ID。这样生成的ID虽然保证了唯一性，但是在整个分布式系统中的连续性不好。

如果需要满足连续性（这里的连续性是指在整个分布式环境中生成的ID的连续性），我们可以用一个独立的系统来完成这个工作：吧所有的ID集中在一个地方进行管理，对每个ID序列独立管理，每台机器使用ID时都从这个ID生成器上进行获取。

跨库join：

可以进行部分数据冗余

（数据冗余如何同步<https://www.w3cschool.cn/architectroad/architectroad-redundant-table.html>）





# 索引

## 为什么要使用索引？

- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性
- 可以大大加快数据的检索速度（大大减少检索的数据量），这也是创建索引的**最主要**原因。
- 帮助服务器避免排序和临时表
- 将随机IO变为顺序IO
- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

## 索引这么多优点，为什么不对表中每一列创建一个索引呢？

- 当对表中的数量进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
- 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如过要简历聚簇索引，那么空间会更大。
- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

## 索引是如何提高查询速度的

将无序的数据变成相对有序的数据结构（就像查目录一样）（介绍B+树的结构）

## 使用索引的注意事项

- 在经常需要搜索的列上，可以加快搜索的速度；
- 在经常使用在Where子句中的列上创建索引，加快条件的判断速度；
- 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
- 对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很多，不适合建索引（用一种技术来区分要查询哪一组数据,比如分区技术,水平分表技术）；
- 在经常用连接的列上，这些列上主要是一些外键，这些列主要是一些外键，可以加快连接的速度；
- 避免where子句中对字段施加函数，这样会造成无法命中索引；
- 在使用innoDB的时使用与业务无关的自增作为主键，即使用逻辑主键，而不要使用业务主键；
- 将打算加索引的键设置为NOT NULL，否则将导致引擎放弃使用索引而进行全表扫描；
- 删除长期未使用的索引，不用打索引的勋在会造成不必要的性能损耗，MySQL5.7可以通过查询sys库的chema_unused_indexes视图来查询那些索引从未被使用；
- 在使用limit offset查询缓慢时，可以借助索引来提高性能；

## MySQL索引主要使用的两种数据结构（还有全文索引）

哈希索引：对于哈心索引来说，底层数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最大；其余大部分场景，建议使用BTree索引。

BTree索引：MySQL的BTree索引使用的是B树中的B+树，但对于主要的两种存储殷勤（MyISAM和innoDB）的实现方式是不同的。

# 索引覆盖

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为"覆盖索引"

我们知道再innoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要"回表”，也就是通过主键再查找一次，这样会比较慢，覆盖索引就是把查询出的列和索引是对应的，不做回表操作！

例子：现在我创建了索引（username，age），在查询select username, age from user where username='Java' and age=22.要查询的列在叶子节点都存在，所以就不用回表。



1.PRIMARYKEY（主键索引）

```
`mysql>altertabletable_nameaddprimarykey(`column`)`
```

2.UNIQUE或UNIQUEKEY(唯一索引)

```
`mysql>altertabletable_nameaddunique(`column`)`
```

3.FULLTEXT(全文索引)

```
`mysql>altertabletable_nameaddfulltext(`column`)`
```

4.INDEX(普通索引)

```
`mysql>altertabletable_nameaddindexindex_name(`column`)`
```

5.多列索引(聚簇索引)

```
`mysql>altertable`table_name`addindexindex_name(`column1`,`column2`,`column3`)`
```

修改表中的索引：

```
`altertabletablenamedropprimarykey,addprimarykey(fileda,filedb)`
```





# B+树索引：

什么情况下应该建立b+树索引：cardinary值比较高（区分度比较高）的时候适合建立b+树索引

b+树结构：

![image-20190810151805600](/Users/pangxinyu/Documents/每日学习文稿/学习笔记md/图片/image-20190810151805600.png)

**根结点**和**中间结点**只存储**主键**，所有记录都在叶子结点（叶子结点存放地址）上，并且是顺序存放的。

可以有效减少IO次数，速度快。（假设一次IO可以从磁盘取500k的数据，如果主键和表项一起存，那么一次可以遍历的条目就会少很多。并且一次只能读一层）

​	聚集索引：对主键建立b+树，表项按照物理地址顺序存储。

​	非聚集索引（二次索引）：一张表只能有一个聚集索引，但可以有多个非聚集索引。定义：对于非主键建立的索引。先通过非聚集索引的b+树找到主键，然后用这个主键去聚集索引的b

+树找。

​	组合索引：最左前缀原则。

​	一棵树，有多个辅助索引集合在一起的。

例子：p6，money，age



**全文索引：**



**哈希索引**：自适应哈希索引，





# 事务

（1） **事务的概念**：由一句或者一组SQL语句组成，是访问并更新数据库中各种数据项的一个程序执行单元，具有ACID特性。

（2） **ACID**：

​              原子性(atomicity):事务要么做，要么不做。

​              一致性（consistency）:事务执行前后数据库完整性约束不会被破坏。

​              隔离性（isolation）：事务在并发执行时的执行对象对其他事务分离。

​              持久性（durability）：事务一旦提交，则结果是永久性的。

（3） **事务的分类**：

扁平事务

带有保存点的扁平事务

链事务

嵌套事务

分布式事务

**（4）事务的实现**

（1）**redo log(重做日志)**:

功能:保证持久性，在服务器重启时检查重做日志保证事务的持久性。

log内容:物理页信息(性能优于binlog)。

组织结构:重做日志缓冲+重做日志文件。

参数innodb_flush_log_at_trx_commit用来控制重做日志刷新到磁盘的策略：

选择级别:0(每隔1s master thread进行写入，执行fsync操作)；2(每次提交事务写入缓冲，快但是有风险)

存储结构:log block

log生命周期：持久化

（2）**undo log (事务提交后purge)**:

功能:保存事务的回滚信息。

log内容:物理页信息。

存储结构:rollback段(限制最大并发事务量)* undolog页(多个事务可重用)

purge操作:根据history list进行删除。

Log生命周期： 事务结束后purge thread根据时机清除。

## 事务隔离级别

 SQL 标准定义了四个隔离级别: 

**READ-UNCOMMITTED(读取未提交)**: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻 读或不可重复读
 **READ-COMMITTED(读取已提交):** 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读 仍有可能发生 

**REPEATABLE-READ(可重复读)**: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修 改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
 **SERIALIZABLE(可串行化)**: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务 之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 

# 日志

redo log

Undo log:磁盘上不存在单独的undo log 文件，他存放在数据库内部的特殊段（segment）中。存放事务回滚的。（和事务的生存周期是一样的）

binlog：全量数据迁移或者分布式数据库增量同步时使用



# 并发控制

锁和mvcc



幻读：当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。

对实时性要求不高对情况：通过**多版本并发控制**解决了幻读的问题（并发性高，可能读取到历史数据）

innodb用通过Next-Key Lock锁定事务需要读取的行，解决幻读问题。

脏读是读取到未提交的数据（需要将事务隔离级别设置为read uncommitted才会产生）

不可重复读读取到的是已经提交的数据。

# 锁

<https://juejin.im/post/5aaf6ee76fb9a028d3753534>

锁是数据库系统区别于文件系统的一个关键特性

基本的封锁有两种：排他锁和共享锁

#### 活锁

活锁是某事务可能永远等待，这是活锁的情形

解决方法：简单方法是采用先来先服务的策略。当多个事务请求封锁同意数据时，封锁子系统请求锁的先后次序对事务进行排队，数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁。

#### 死锁

由于两个或多个事务都已经封锁了一些数据对象，然后又请求已经被事务锁住的数据，这些事务永远都不能结束，就形成了死锁。

预防死锁：

**一次封锁法**：要求每个事务必须一次将所有要使用的数据全部加锁，否则不能执行下去。一次封锁法虽然可以有效的防止死锁的发生，但是增加了锁的粒度，从而降低了系统的并发性。并且数据库时不断变化的，所以事先很难精确地确定每个事务所需进行加锁的对象，为此只能扩大封锁范围，将事务执行可能需要封锁的数据对象全部加锁，这就进一步降低了并发度。

**顺序封锁法**：预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实施封锁。（很难按规定的顺序去实施加锁，因为事先难以确定每一个事务要封锁哪些对象）

由此可见**数据库不适合预防死锁**

#### 死锁的诊断与解除

**诊断：**

1.超时法：如果一个事务的等待时间超过了时限，那么就认为其发生了死锁。

优点：实现简单

不足：1。可能误判死锁：如事务因为其他原因而使等待时间超过时限，系统就会误认为发生了死锁；若时限设置得太长，则不能及时发现死锁。

2.事务等待图法：事务等待图是一个有向图G=（T，U），T为结点的集合，每个节点表示正在运行的事务。事务等待图动态地反应了所有事务的等待情况，并发控制子系统周期性（比如每隔数秒）生成事务等待图，并进行检测，如果发现图中存在回路，则表示系统中出现了死锁。

检测工具：

Jstack工具可以用于生成java虚拟机当前时刻的线程快照。线程快找是当前java虚拟机内每一条线程正在执行的方法对战的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如`线程间死锁`、`死循环`、`请求外部资源导致的长时间等待`等。

`jps`确定当前执行任务的进程号

`jstack -F 1362`

**解除：**

选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有锁。（对撤销的事务锁进行的数据修改加以恢复）

## 两段锁协议

两段锁协议规定所有的事务应遵守的规则：

① 在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁。

② 在释放一个封锁之后，事务不再申请和获得其它任何封锁。

即事务的执行分为两个阶段：

第一阶段是获得封锁的阶段，称为扩展阶段。

第二阶段是释放封锁的阶段，称为收缩阶段。

若所有事务均遵守两段锁协议，则这些事务的所有交叉调度都是可串行化的。





### 2.3 InnoDB关键特性：为InnoDB提供更好的性能以及可靠性

​     (1) 插入缓冲（Insert Buffer）：解决离散写问题    

​    (2）两次写（Double Write）：解决数据可靠性（宕机页失效）

​    (3) 自适应哈希索引(Adaptive Hash Index)：提高读写效率

​    (4) 异步IO(Async IO)：加速io，合并io

​    (5) 刷新邻接页 (Flush Neighbor Page)：合并io

# 引擎

innoDB与MyISAM引擎的区别

两者都适用B+树作为索引结构

不同点

| innoDB                                   | MyISAM                                           |
| ---------------------------------------- | ------------------------------------------------ |
| 叶子节点保存了完整的数据记录（聚集索引） | 叶子结点记录的是地址（非聚集索引）               |
| 事务安全型                               | 非事务安全型                                     |
| 支持行级锁定                             | 锁的粒度是表级                                   |
| 不支持全文索引（5.6后支持）              | 支持全文索引                                     |
|                                          | 保存成文件的形式，在咖平台转移中使用会省去不少事 |

应用场景：

MyISAM管理非事务表，它提供高速存储和检索，以及全文搜索能里，如果应用中需要执行大量的select查询，那么MyISAM是更好的选择；

InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持，如果应用中需要执行大量的INSERT或UPDATE，则应该使用innoDB，这样可以提高用户并发操作的性能。

innoDB中辅助索引：辅助索引data域存放的是相应记录的主键而不是地址，先取出主键的值，再走一遍主索引。（因此在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会导致主索引频繁分裂）