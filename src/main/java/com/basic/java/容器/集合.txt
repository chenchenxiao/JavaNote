List继承自Collection接口，有两种类型的List
    1、ArrayList：底层是一个数组，擅长于随机访问元素，直接通过get的方式，类型于取下标，所以很快，但是在插入和删除时慢
                  因为插入后底层数组的顺序就又要重新排一遍，删除同理
    2、LinkedList：链表结构，在插入和删除时很快，但是访问元素时慢，因为需要一个一个去访问，特性集比ArrayList更大

Set继承自Collection接口，不保存重复的元素
    HashSet:使用散列函数来存储，无序

    TreeSet:将元素存储在红黑树结构中，有序

迭代器
    Iterator：单向迭代，是线程安全的，不允许修改集合内容，如果修改了会抛出ConcurrentModificationException
    ListIterator:只能遍历List，双向迭代，不是线程安全的，可以修改集合内容，有相应的方法

HashMap
    初始容量：是哈希表在创建时的容量，默认是16
    加载因子：是哈希表在其容量自动增加之前可以达到多满的一种尺寸.默认是0.75
              越大，数据分布过于密集，容易造成冲突，查找效率就低下，越低，数据分布越稀疏，空间严重浪费
    当哈希表中的条目数超过初始容量与加载因子的乘积时，则要对该哈希表进行refresh操作，加载因子越大，填满的元素越多
    空间的利用率高了，但是冲突的机会大了，反之也是一样的道理
    源码分析看：http://www.cnblogs.com/ToBeAProgrammer/p/4787761.html
                http://blog.csdn.net/u014026363/article/details/56342142
                http://www.admin10000.com/document/10464.html

    总结：
        1、HashMap的底层是一个数组，数组每个元素又都是一个链表，所以类似于拉链，是因为不同key的hash运算后可能是同一结果
        2、在HashMap里面，有初始容量和加载因子，还有一个门限值，门限值 = 初始容量 * 加载因子
           当超过这个值时，HashMap李的数组会进行扩容
        3、HashMap是非线程安全的，所以一旦在使用跌代器时，有其他线程修改了Map，就会报错ConcurrentModificationException

        4、HashMap在存储值时，如果key的hash值相同，也就是在数组中的位置相同，这就是冲突，HashMap以链表的存储结构来解决冲突
           使用使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不           同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。

        5、、构造器：
            1）无参构造器：使用默认的加载因子和默认的初始容量
            2）有参构造器：
                1、指定加载因子和初始容量
                2、把一个Map添加到当前Map，使用该构造器时会先判断被添加Map的长度，然后再判断当前Map
                   如果当前Map为空，就先计算出加载因子，然后拿去和门限值比较，如果大于门限值就会重新计算门限值
                   如果当前Map不为空，就会判断被添加的Map长度是否大于门限值，如果大于就进行扩容
                   然后再通过循环遍历把被添加的Map添加到当前Map

        6、put方法：
            会调用putVal方法，会先判断当前Map是否为空或者长度是否为0，如果是就进行初始化
            根据key的哈希值和当前长度进行哈希运算，得出key对应的索引，判断索引位置是否为空，若为空，直接put一个新节点
            如果索引位置有值，先把索引位置的hash与计算出的key值的hash和两个key进行比较，如果都相同，则直接覆盖
            如果不相同，且索引对应的节点是红黑树结构的，则按红黑树的方式添加节点
            否则说明是以链表结构存储的，会先找到链表的最后一个节点，添加新节点
            如果链表的长度大于阀值8，则调用treeifyBin方法(当前map为空，或长度小于64时，进行resize扩容，如果已经大于64，则将链表变为红黑树结构）
            如果链表的某个节点的hash和key与传进来的hash和key都相同，则表示该节点就是所要节点，修改该节点的值，并且返回oldValue
            最后会判断当前map的长度是否大于门限值，如果大于则进行扩容

        7、get方法
            会调用getNode方法。先判断当前Map是否为空，长度是否为0，并且根据key的hash运算的值和当前Map长度得出的索引位置判断
            对应位置是否有值，如果都没有则直接返回Null,否则先比较索引位置的key和hash是否与待查找的一样
            如果一样则直接返回该索引位置节点，如果不一样，并且索引对应节点是红黑树结构的，则按红黑树方式查找，
            否则就遍历链表，找到key和hash值与待查找的一样则返回找到的节点，否则返回null，最后get方法会返回节点对应的value

HashTable
    可以看作是线程安全的HashMap，基本上是一样的，每个方法都加了synchronized关键字来实现同步。
    不同的是它是默认初始容量是11，扩容是以2n+1的形式扩容，会使取模hash的结果更均匀，所以HashTable的哈希表大小选择更好，
    而HashMap则是以2n的形式扩容，可以直接使用位运算来得到结果，所以hash运算效率更高