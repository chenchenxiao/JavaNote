1、类的整个声明周期：加载，验证，准备，解析，初始化，使用，卸载

2、加载，验证，准备，初始化，卸载这五个阶段是按顺序进行的，而解析在某些情况下可以在初始化后进行，
   这几个阶段通常都是交叉混合进行的，通常会在一个阶段执行时调用、激活另一个阶段

3、五种对类进行初始化的情况，其他情况都不会对类进行初始化
    ① 通过new实例化一个对象，或者调用类的static方法，static属性时
    ② 对类进行反射操作时
    ③ 当初始化一个类时，如果发现其父类没有初始化过，则先对其进行初始化
       但是当接口在初始化时，不会要求其父接口全部完成初始化，只有当真正使用到父接口（如引用接口定义的常量）的时候，才会初始化
    ④ 当虚拟机启动时，会初始化包含main方法的类

4、数组是由java虚拟机直接创建的，不通过类加载器创建，但是数组的元素类型还是要靠类加载器去创建

5、加载阶段与连接阶段的部分内容（如对字节码文件格式的验证）是交叉进行的，加载阶段尚未开始，连接可能已经开始


class装载验证流程：
	1、加载
		装载类的第一个阶段，取得类的二进制流(Class文件的二进制数据)，读入内存，这些二进制数据所代表的存储结构会被转化为方法区中运行时的数据结构
		存储在运行时数据区的方法区内，在内存中生成对应的class对象，用来封装类在方法区内的数据结构
	2、连接：把已经读入内存的二进制数据合并到java虚拟机的运行环境中去
		验证：正常情况下都是通过javac来编译的，所以都是正确的，但是如果是用户自己手动生成一个java字节码文件，就需要验证了
			目的：保证Class文件的字节流中包含的信息是正确的，不会危害虚拟机自身安全
			（1）文件格式的验证：验证字节流是否符合Class文件的规范
				①是否以0xCAFEBABE开头（是否是一个java虚拟机能接受的Class文件）
				②版本号是否合理
				目的：保证输入的字节流能正确解析并存储到方法区中，是基于十二进制字节流进行验证的

			（2）元数据验证：对字节码描述的信息进行语义分析，保证其描述的信息符合规范要求
			                 对元数据中的数据类型做校验
				①是否有父类
				②是否继承了final类
				③非抽象类是否实现了所有的抽象方法
				目的：对类的元数据进行校验，保证元数据都是符合规范的

			（3）字节码验证（很复杂）：通过数据流和控制流分析，确保程序是合法的，对类的方法体进行校验
				①运行检查
				②栈数据类型和操作码数据参数吻合
				③跳转指令指定到合理的位置
				④类型转换是有效的

			（4）符号引用验证:发生在符号引用转为直接引用的时候，即解析阶段，
			                  对常量池中的各种符号引用的信息进行匹配性校验，确保解析动作能正常执行
				①常量池中描述类是否存在
				②访问的方法或字段是否存在足够的权限

		准备：
			分配内存，并为类设置初始值（方法区中），只为类变量分配，实例变量会在类初始化时在堆中分配
			public static int v=1;在准备阶段中，v会被设置为0
			在初始化的构造器中才会被设置为1，对于static final类型，在准备阶段就会被赋上正确的值
			public static final  int v=1;

		解析：解析的内容有类或接口，字段，类方法，接口方法
			符号引用替换为直接引用
			--字符串引用对象不一定被加载
			--直接引用就是指针或地址偏移量，引用对象一定在内存中
		解析器：
			执行类构造器
				静态成员或方法先执行
			子类的构造器调用前一定会先执行父类的构造器
			构造器是线程安全的

	3、初始化
	    给已分配空间的属性赋值
	    会执行两个方法：clinit类初始化和init实例初始化
        <clinit>()方法：是编译器自动收集类中的所有类变量和静态语句块(static{})中的语句合并而成的。
            知道这一点很重要，而<clinit>()方法里面语句的顺序由源程序代码决定。
            多个线程去初始化一个类时，只能有一个线程去执行这个类的clinit方法，其他都会阻塞，这也是为什么static语句只会被执行一次
            <clinit>()方法和类实例构造器<init>()方法是不同的。同一个类加载器，一个类型只会初始化一次，对应此方法只被调用一次。
        <init>()方法：涉及到实例代码块、构造方法的调用的执行。
            同时，实例化几次类，则进行“实例代码块”和“构造器方法”的几次调用
            并且，“实例代码块”优先于“构造器方法”的调用。

	ClassLoader：把Class加载到JVM中
	    ClassLoader是一个抽象类，它的实例将读入java字节码将类装载到JVM中
	    ClassLoader可以定制，满足不同的字节码流获取方式
	    ClassLoader负责装载过程中的加载阶段

	    默认设计模式-----分类
	    BookStrap ClassLoader ---- 启动ClassLoader
	    Extension ClassLoader ---- 扩展ClassLoader
	    App ClassLoader ---- 应用ClassLoader
	    Custom ClassLoader ---- 自定义ClassLoader
	    除了启动类加载器，每个ClassLoader都有一个Parent作为父类
	    默认是自底向上的检查类是否能够完成这个加载请求，如果无法加载，再自上向下的加载类，加载不到就0报错

	    在ClassLoader中，顶层的无法访问底层的类，解决方法：
	        使用一个上下文加载器，在顶层ClassLoader中，传入底层的ClassLoader

	    类加载器间的层次关系称作双亲委派模型