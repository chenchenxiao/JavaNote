#### 并发控制
    1、mysql会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。
        例如：对于select语句，在解析查询之前，服务器会先检查查询缓存，如果能在其中找到对应的查询，服务器就不必再执行查询解析，优化和执行的过程，
              而是直接返回查询缓存中的结果集

    2、读写锁：
           读锁是共享的，或者说是相互不阻塞的。多个用户在同一时刻可以同时读取同一个资源，而互不干扰。
           写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，这是处于安全策略的考虑，只有这样，
               才能保证在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源
           写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面

    3、锁粒度：
        每种Mysql存储引擎都可以实现自己的锁策略和锁粒度。在存储引擎的设计中，锁管理是非常重要的决定。
        将锁粒度固定在某个级别，可以为某些特定的应用场景提供更好的性能，但同时却会失去对另外一些应用场景的良好支持

    4、表锁：
        表锁是Mysql中最基本的锁策略，并且是开销最小的策略。
        他会锁定整张表，一个用户在对表进行写操作（插入，删除，更新等）前，需要先获得锁，这会阻塞其他用户对该表的所有读写操作，
        只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的

      间隙锁：
        当用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件而已有数据记录的索引项加锁；
        对于键值在条件范围内但不存在的记录，叫做“间隙”，InnoDB也会对这个“间隙”加锁。
            实现目的： 1.防止间隙内有新数据被插入
                      2.防止已存在数据，更新成间隙内的数据
                      总的也就是通过间隙锁来防止幻读   
            innodb自动使用间隙锁的条件：
                1.必须在RR（可重复读）级别下
                2.检索条件必须有索引
    
    5、事物：
        四大特性
            原子性（A）：一个事物必须被视为一个不可分割的最小工作单元，整个事物的所有操作要么全部提交成功，要么全部失败回滚
                         对一个事物来说，不可能只执行其中的一部分操作，这就是事物的原子性
            一致性（C）：数据库总是从一个一致性的状态转化到另一个一致的状态
                         比如：AB共有500，无论转账多少次，事物结束后AB加起来还是500
            隔离性（I）：一个事物所做的修改在最终提交之前，对其他事物都是不可见的
            持久性（D）：一旦事物提交，则其所做的修改就会永久保存到数据库中

    6、隔离级别：
        未提交读（脏读）：事物中的修改，即使没有提交，对其他事物也都是可见的，事物可以读取未提交的数据。
        提交读（不可重复读）：一个事物开始时，只能看见已经提交的事物所做的修改，也就是说，一个事物从开始到提交之前，所做的修改对其他事物都是不可见的。发生在update
                              因此两次执行同样的查询，可能会得到不同的结果
        可重复读（幻读）：当某个事物在读取某个范围内的记录时，另外一个事物又在该范围内插入了新的记录，当之前的事物再次读取该范围的记录时，会产生幻读，发生在insert和delete
                          这是Mysql默认的事物隔离级别
        可串行化：强制事物串行执行，避免了幻读的问题，会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。

    7、死锁：
        死锁是指两个或者多个事物在同一个资源上相互占用，并请求锁定对方占有的资源，从而导致恶性循环的现象。
        当多个事物试图以不同的顺序锁定资源时，就可能会产生死锁，多个事物同时锁定同一个资源时，也会产生死锁。
        锁的行为和顺序是与存储引擎相关的，以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。
        死锁产生有双重原因：有些是真正的因为数据的冲突，这种情况通常很难避免，但有些则完全是由于存储引擎的实现方式导致的
        死锁发生后，只有部分或者完全回滚其中一个事物，才能打破死锁

####Schema与数据类型优化
    1、一般情况下，要尽量使用可以正确存储数据的最小类型，因为小类型占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期更少
       通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值。因为可为NULL的列难优化，使得索引，索引统计和值比较更为复杂，会使用更多的存储空间

    2、一旦选择了一种类型，要确保在所有关联表中都用同样的类型，在可以满足值的范围的需求，并且预留未来增长空间的前提下，应该选择最小的数据类型

    3、应该避免使用字符串类型作为标识列，因为很消耗空间，并且通常比数字类型慢。
       对于MD5，SHA1或UUID生成的字符串，这些新值会任意分布在很大的空间内，会导致导致INSERT和SELECT语句变得很慢
           ①因为插入值会随机写到索引的不同位置，使得INSERT语句更慢，会导致页分裂，磁盘随机访问
           ②SELECT语句变得更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方
           ③随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的访问局部性原理失效

    4、设计表时需要注意的东西
           ①不能有太多的列，从行缓冲列这将编码过的列转换成行数据结构的操作代价是非常高的
           ②不能有太多的关联
           ③全能的枚举。就是一个枚举里面有许多的值，正确的做法应该是用整数作为外键关联到字典或者查找表来查找具体值
           ④变相的枚举。允许在列中存储一组定义值中的单个值，集合列则允许在列中存储一组定义值值的一个或多个值，有时候这可能比较容易导致混乱

    5、范式的优缺点
           优点：
               1、范式化的更新操作通常比反范式化的要快
               2、当数据较好地范式化时，就只有很少或者没有重复数据，所有只需要修改更少的数据
               3、范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快
               4、很少有多余的数据意味着检索列表数据时更少需要DISTINCT或GROUP BY语句
           缺点：
               范式化的表的通常需要关联，稍微复杂一些的查询语句在符合范式的表上都可能需要至少一次关联

    6、反范式化的优缺点：
           1、反范式化的表因为所有数据都在一张表中，可以很好地避免关联

    7、mysql执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表

####索引

    优点：
        ① 索引大大减少了服务器需要扫描的数据量
        ② 索引可以帮助服务器避免排序和临时表
        ③ 索引可以将随机I/O变为顺序I/O

    1、索引可以包含一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为Mysql只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的

    2、B-Tree
       ① Mysql索引类型没有特别指定的时候都是指B-Tree索引，它使用B-Tree数据结构来存储数据
       ② 存储引擎以不同的方式使用B-Tree索引，性能也各有不同，各有优劣
       ③ B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索
       ④ B-Tree对索引列是顺序组织的，所以很适合查找范围数据
       ⑤ B-Tree索引使用=于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找
              有 全值匹配，匹配最左前缀，匹配列前缀，匹配范围值，精确匹配某一列并范围匹配另外一列，只访问索引的查询
       ⑥ 因为索引树的节点是有序的，所以除了按值查找之外，所以还可以用于查询值的ORDER BY操作
       ⑦ 如果不是按照索引的最左列开始查找，则无法使用索引   （带头大哥不能少）
       ⑧ 不能跳过索引中的列     （中间兄弟不能断）
       ⑨ 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找     （范围之后全失效）

    3、哈希索引
       ① 只有精确匹配所有列的查询才有效， 对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，
          并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引值，同时在哈希表中保存指向每个行数据的指针
       ② 因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。
       ③ 限制：
              1 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。
                不过，访问内存值的行的速度很快，所以大部分情况下这一点对性能的影响并不明显
              2 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序
              3 哈希索引也不支持部分索引列匹配查找的，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。也就是必须查询所有的索引列
              4 哈希索引只支持等值比较查询，包括= in ，不支持任何范围查询
              5 当出现哈希冲突时，存储引擎必须遍历链表值所有的行指针，逐渐进行比较，直到找到所有符合条件的行
              6 如果哈希冲突很多的话，一些索引维护操作的代价也会很高
       MariaDB引擎支持该索引

    4、自适应哈希索引
       InnoDB引擎有一个特殊的功能叫做自适应哈希索引，当某些索引值被使用得非常频繁时，他会在内存值基于B-Tree索引之上再创建一个哈希索引，这样就具备哈希索引的快速查找优点

    5、空间索引
        MyISAM表支持空间索引，可以用作地理数据存储，这类索引无须前缀查询，空间索引会从所有维度来索引数据

    6、全文索引
        全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引值的值，
        在相同列上同时创建全文索引和基于值的B-Tree索引不会有冲突
        MyISAM支持，5.7后InnoDB也支持了

    7、三星系统
        一星： 将相关的记录放到一起获得一星
        二星： 如果索引中的数据顺序和查找中的排列顺序一致则获得二星
        三星： 如果索引中的列包含了查询中需要的全部列则获得三星

####高性能的索引策略
    1、独立的列：如果查询中的列不是独立的，则Mysql就不会使用索引，独立的列是指索引列不能是表达式的一部分，也不能是函数的参数

    2、前缀索引和索引选择性
           索引的选择性是指，不重复的索引值和数据表的记录数的比值，索引的选择性越高则查询效率越高，因为可以让Mysql过滤更多的行
           前缀索引是一种能使索引更小，更快的有效方法，但另一方面也有缺点：无法使用前缀索引做GROUP BY 和 ORDER BY，也无法做覆盖扫描

    3、多列索引  不是建立多个单个索引的列，而是指一个索引有多个列

    4、选择合适的索引列顺序  按最左列进行排序，将选择性最高的列放到索引最前列

####聚簇索引
    1、并不是一种单独的索引类型，而是一种数据存储方式，具体细节依赖具体实现，InnoDB的聚簇索引实际上在同个结构中保存了B-Tree索引和数据行

    优点：
        ① 可以把相关数据保存到一起
        ② 数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比非聚簇索引快
        ③ 使用覆盖索引扫描的查询可以直接使用叶节点中的主键值

    缺点：
        ① 提高了IO密集型应用的性能，但如果数据全部放在内存中，则访问的顺序就没那么重要了
        ② 插入速度严重依赖于插入顺序
        ③ 更新聚簇索引列的代价很高
        ④ 基于聚簇索引的表在插入新行时，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题
        ⑤ 聚簇索引可能导致全表扫描变慢
        ⑥ 二级索引访问需要两次索引查找，而不是一次
        
        不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。
        用非单调的字段作为主键在InnoDB中不是好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，
        十分低效，而使用自增字段作为主键则是一个很好的选择

####InnoDB按主键顺序插入行
        不按顺序插入的缺点(uuid)：
            ① 写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中
            ② 因为写入是乱序的，InnoDB不得不频繁地做页分裂操作，以便为新的行分配空间，页分裂会导致移动大量数据
            ③ 由于频繁的页分裂，页会变得稀疏并不规则地填充没所以最终数据会有碎片
        使用InnoDB时应该尽可能地按主键顺序插入数据，并且尽可能地使用单调增加的聚簇键的值来插入新行
        
####覆盖索引
        如果一个索引包含所有需要查询的字段的值，就叫覆盖索引
        优点：
            ① 索引条目通常小于数据行大小，所以如果只需要读取索引，那Mysql就会极大地减少数据访问量
            ② 因为索引是按照列值顺序存储的，所以对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO少得多
            ③ InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询
            ④ 不是所有类型的索引都可以成为覆盖索引，Mysql只能使用B-Tree索引作为覆盖索引

        无法使用覆盖索引的情况：
            ① 没有索引会覆盖所有的列
            ② 不能在索引中执行LIKE操作

####使用索引扫描来做排序
        1.Mysql有两种方式可以生产有序的结果，通过排序操作，或者按索引顺序扫描。
        2.只有当索引的列顺序和ORDER BY字句的顺序完全一致，并且所有列的排序方向都一样时，Mysql才能使用索引来对结果做排序
        3.如果查询需要关联多张表，则只有当ORDER BY 子句引用的字段全部为第一个表时，才能使用索引做排序，当前导列为常量时，可以不满足最左前缀要求
        4.有一种情况下ORDER BY子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果where或join子句中对这些列指定了常量，就可以弥补索引的不足
        

####压缩索引
        MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中
        压缩的方法是先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余不同的后缀部分，把这部分存储起来即可
        压缩快使用更少的空间，代价是某些操作可能更慢。

####支持多种过滤条件
        需要看看哪些列拥有很多不同的取值，哪些列在WHERE子句中出现得最频繁，在有更多不同值的列上创建索引的选择性会更好，更有效地过滤掉不需要的行
        如果查询没有使用某个列，也可以绕过，例如  SEX IN ('m','f')。可以让Mysql来选择该列，但是若果列太多或者IN的内容太多就不行

####利用索引查询时的三大原则
        ① 单行访问是很慢的。如果服务器从存储中读取一个数据块只是为了获取其中一行，那就浪费了很多工作
        ② 按顺序访问范围数据是很快的，因为顺序IO不需要多次磁盘寻道，比随机IO快，也不需要额外的排序操作，并且GROUP BY也无须再做排序和将行按组进行聚合计算了
        ③ 索引覆盖查询是很快的，如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表查找行
        总的来说，编写查询语句时尽可能选择合适的索引以避免单行查找，尽可能地使用数据原生顺序从而避免额外的排序操作，尽可能使用索引覆盖查询

####查询优化
    1、是否向数据库请求了不需要的数据
    2、查询了不需要的记录
    3、多表查询时返回全部列
    4、总是取出所有列
    5、重复查询相同的数据0
    Mysql使用下面的三种方式应用WHERE条件
        ① 在索引中使用WHERE条件来过滤不匹配的记录，这是在存储引擎层完成的
        ② 使用索引覆盖扫描（Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果，在Mysql服务层完成，无须回表查询
        ③ 从数据表中返回数据，然后过滤不满足条件的记录（Using WHERE），在Mysql服务层完成，需要先从数据表读出记录然后过滤

    如果查询需要扫描大量的数据但只返回少数的行，可以用下面的方法去优化
        ① 使用索引覆盖扫描，把所有需要用到的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了
        ② 改变库表结构
        ③ 重写这个复杂的查询，让Mysql优化器能够以更优化的方式执行这个查询

    重构查询的方式
        ① 将一个大查询分解为多个小查询
        ② 将大查询分切成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。
           例如删除数据，如果一个大语句一次性完成的话，可能需要一次锁住很多数据，占满整个事物，耗尽系统资源，阻塞很多小的但重要的查询
        ③ 分解关联查询， 让缓存的效率高，执行单个查询可以减少锁的竞争，查询本身效率也可能会有所提升，可以减少多余记录的查询
           1)让缓存的效率更高，应用程序可以方便地缓存单表查询对应的结果。
           2)如果关联中的某个表发生了变化，那就无法使用查询缓存了。执行单个查询还可以减少锁的竞争
           3)在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。
           4)查询本身效率也可能会有所提升。
           5)可以减少多余记录的查询，在应用层做关联，意味着对某条记录应用只需查询一次，而在数据库中则可能需要重复地访问一部分数据。

####查询执行的过程
    1、客户端发送一条查询给服务器
    2、服务器先检查查询缓存，通过一个对大小敏感的哈希查找来实现的，写如果命中了缓存，会先检查一次用户权限，如果可以则立即返回存储在缓存中的结果，否则进入下一阶段
    3、服务器进行SQL解析，预处理，再由优化器生成对应的执行计划
    4、Mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询
    5、将结果返回给客户端

    在Mysql的服务器和客户端间的通信中，要么是服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生
    多数连接Mysql的库函数都可以获得全部结果集并存到内存中，还可以逐行获取需要的数据，默认一般是获得全部结果集并缓存到内存中。
    如果需要返回一个很大的结果集时，因为库函数会花很多时间来存储所有的结果集，如果能尽早开始处理这些结果集，就能大大减少内存的消耗，
    这种情况下可以不使用缓存来记录结果而是直接处理，这样做的缺点是，对于服务器来说，需要查询完成后才能释放资源，在交互的过程，服务器的资源都是被这个查询所占用的

    Mysql对任何关联都执行嵌套循环关联操作，即Mysql先在一个表中循环取出单条数据，然后在嵌套循环到下一个表中寻找匹配的行，直到找到所有匹配的行
    可以有多种不同的关联顺序来获得相同的执行结果，关联查询优化器通过评估不同顺序时的成本来选择一个代价最小的关联顺序

    

####UNION
    UNION的限制：Mysql无法将限制条件从外层“下推”到内层，使得原本能够限制部分返回结果的条件无法应用到内层查询的优化上
    例如如果希望UNION的各个子句能够根据LIMIT只取部分结果集，就需要在各个子句中分别使用这些子句

    Mysql不允许在同一张表上同时进行查询和更新，可以通过使用生成表的形式来绕过上面的限制

####优化特定类型的查询
    1、优化COUNT()查询
        COUNT()是一个特殊的函数， ① 用来统计某个列值的数量。也可以统计行数，要求列值是非空的
                                  ② 统计结果集的行数，当使用COUNT(*)时，实际上会忽略所有列而直接统计所有的行数
                                  ③ 没有使用WHERE条件的COUNT是非常快的，因为此时无须实际地去计算表的行数
                                  ④ 有时候某些业务场景并不要求完全精确的COUNT值，此时可以用近似值来代替
    2、优化关联查询
        ① 确保ON或USING子句中的列上有索引，在创建索引的时候就要考虑到关联的顺序
        ② 确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样Mysql才有可能使用索引来优化这个过程
    3、优化LIMIT分页
        ① 尽可能地使用索引覆盖扫描，而不是查询所有的列
        ② LIMIT和OFFSET的问题，其实是OFFSET的问题，它会导致Mysql扫描大量不需要的数据然后再抛弃掉，如果可以使用书签记录上次取数据的位置，下次就可以直接从该书签记录的位置开始扫描
        ...
    4、优化UNION查询
        ① Mysql总是通过创建并填充临时表的方式来执行UNION查询，因此很多优化策略在UNION中都没法很好地使用，要将WHERE,LIMIT等子句写到UNION的各个子查询中。
        ② 除非确实需要服务器消除重复的行，否则就一定要用UNION ALL，如果没有ALL，Mysql会给临时表加上DUSTINCT选项，这会导致对临时表的数据做唯一性检查
       
    5、在不是一定需要使用某个索引时，可以通过某些技巧来使用
       比如sex性别，使用 SEX IN('m','f')来让mysql选择该索引，这样就能使用最左前缀
       
    数据库优化：
        从表方面：字段不能太多，选择合适的数据类型和大小，避免使用NULL，
        从索引：建立合适的索引
        从大的方面：分库，分表，分区，读写分离
       
1.无论是删除主键还是创建主键，都会重建表，所以如果重建或删除主键之前还有别的操作，那这些操作就没用了，可以用alter table engine=InnoDB代替

2. 出现死锁时，有两种解决方案：
    （1）直接进入等待，知道超时，通过innodb_lock_wait_timeout来设置
    （2）发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务继续执行，将innodb_deadlock_detect设置为on开启

3.如果在事务中要锁多个行，要把最可能造成锁冲突，最可能影响并发度的锁的申请时机尽量往后放

4.减少死锁带来的影响：
    (1) 拆行，将一行拆成多行
    (2) Server层限流，对于相同行的更新，在进入引擎之前进行排队
    (3) 关闭死锁检测，但是可能会超时比较多
    
5.唯一索引和普通索引的区别
    (1) 唯一索引在查找时找到记录会停，而普通索引找到记录后会继续找下一个不符合条件的记录
    (2) change buffer：更新数据时，如果数据页在内存中就直接更新，如果不在的话，InnoDB会将更新操作缓存在change buffer中，这样就不需要从磁盘读入这个数据页，
        下次需要访问这个数据页时，将数据页读入内存，然后执行change buffer中与这个页有关的操作即可，这样可以减少磁盘的IO，试用与写多读少的情况，因为这样一次merge操作即可，
        唯一索引更新时需要判断记录是否唯一，这个操作需要在内存中判断，所以唯一索引不适合使用change buffer，普通索引比较适合。
