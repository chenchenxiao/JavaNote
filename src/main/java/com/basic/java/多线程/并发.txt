一 线程安全性

    解决一个可变状态的变量没有使用同步的方法：
        1、不在线程间共享该状态变量
        2、将状态变量修改为不可变的变量
        3、在访问状态变量时使用同步

    一个线程安全类的定义：
        当多个线程访问一个类时，不管运行环境采用何种调度方式或者这些线程将如何交替执行，
        并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那就是线程安全的

    竞争条件：
        “先检查后执行”，即通过一个可能失效的测试结果来决定下一步的动作，例如  i++
         要避免该问题就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，
         从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中

    原子操作：
        对于访问一个状态的所有操作来说，这个操作是以一个原子方式执行的
        要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量

    内置锁：
        java提供了一种内置的锁机制来支持原子性：同步代码块（synchronized）
        同步代码块包括两个部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块
        内置锁是一种互斥体，也就是最多只有一个线程能持有这个锁，其他线程要想获得锁
        必须等待持有锁的对象释放锁，否则就会阻塞

    重入：
        重入意味着获取锁的操作粒度是“线程”，而不是调用（互斥锁就是调用）
        如果一个线程试图获取一个已经由它自己持有的锁，那么这个请求就会成功

    用锁来保护状态
        访问共享状态的复合操作，都必须是以原子操作以避免产生竞态条件
        对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，用同一个锁来保护
        对象的内置锁与其状态间没有内在的关联，每个共享的和可变的变量都应该只由一个锁来保护
        对于每个包含多个变量的不变性条件，其中涉及的所有变量都由同一个锁来保护

二、对象的共享

    在没有同步的情况下，编译器，运行器以及运行时等都可能堆操作的执行顺序进行一些意想不到的调整，也就是指令重排序

    最低安全性：
        当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值
        这种安全性保证就叫最低安全性

    对于long，double等64位数值变量的读写操作，JVM会分解为两个32伪的操作
    当读取一个非volatile类型的long变量时，如果是在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位

    发布对象：使对象能够在当前作用域外的代码中使用
    对象逸出：当某个不该发布的对象被发布时，就是对象逸出
    发布和逸出的对象里包含的对象也会发布或逸出

    final域
    final类型的域是不能修改的，如果final修饰的是一个对象引用，则该引用是不可变的，而引用指向的对象还是可变的

    任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步

    对象安全发布的方式：
        1、在静态初始化函数中初始化对象引用
        2、将对象的引用保存到volatile类型的域或者AtomicReference对象中
        3、将对象的引用保存到某个正确构造对象的final类型域中
        4、将对象的引用保存到一个由锁把保护的域中

    事实不可变对象：对象从技术上来看是可变的，但其状态在发布后不会再改变，这种对象就是“事实不可变对象”
    在没有额外的同步情况下，任何线程都可以安全地使用被安全发布的事实不可变对象
    比如被当作Value的Date被存到CurrentHashMap中，Date看起来是可变的，但事实上是不可变的

    对象的发布取决于它的可变性
        不可变对象可以通过任意机制来发布
        事实不可变对象必须通过安全方式来发布
        可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来