1.B+树每层节点都是按照索引列的 值从⼩到⼤的顺序排序⽽组成了双向链表。
  不论是叶⼦节点中 的记录，还是内节点中的记录（也就是不论是⽤户记录还是⽬ 录项记录）
  都是按照索引列的值从⼩到⼤的顺序⽽形成了⼀个 单向链表。⽽增、删、改操作可能会对节点和记录的排序造成破坏，
  所以存储引擎需要额外的时间进⾏⼀些记录移位，页⾯分裂、页⾯回收啥的操作来维护好节点和记录的排序。

2.如果我们想使⽤联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列

3.匹配列前缀:为某个列建⽴索引的意思其实就是在对应的B+树的记 录中使⽤该列的值进⾏排序,对字符串的匹配就是通过匹配列前缀的，比较第一个字符的大小，想同就比较第二个。。
    所以想用like做模糊查询时，只能保留后面%号，假如是%AS%，此时无法保证拥有AS的字符串都是排列的，无法用到索引

4.匹配范围值:如果对多个列同时进 ⾏范围查找的话，只有对索引最左边的那个列进⾏范围查找的时候才能⽤到B+树索引,
  因为只有最左边的列是按第一个索引列排序的，拿到的数据可能不会按第二个索引列排序，因为第一个列的值不是相等的，无法使用第二个索引排序，所以无法使用索引

5.精确匹配某⼀列并范围匹配另外⼀列：精确匹配的列拿到的数据是相同的，所以会按第一个范围索引列进行排序

6.order by排序：如果ORDER BY的⼦句后边的列的顺序 是按照索引列的顺序给出的，
                因为B+树的记录本身就是按索引列的值进行排序的，所以直接从索引中提取数据，然后进⾏回表操作取出该索引中不包含的列就好了
                要求各个排序列的排序顺序必须是⼀致的，要么一起DESC,要么ASC

7.group by分组：如果分组的顺序跟索引的顺序一样也会用到索引，否则会在内存中实现分组

8.只为⽤于搜索、排序或分组的列创建索引：也就是说，只为出现在WHERE⼦句中的列、连接⼦句中的连接列，
                                        或者出现在ORDER BY或GROUP BY⼦句中的列创建索引。⽽出现在查询列表中的列就没必要建⽴索引了

9.考虑列的基数：列的基数指的是某⼀列中不重复数据的个数，在记录⾏数⼀定的情况下，列的基数越⼤，该列中的值越分散，
                列的基数越⼩，该列中的值越集中,这个列的基数 指标⾮常重要，直接影响我们是否能有效的利⽤索引。
                假设某个列的 基数为1，也就是所有记录在该列中的值都⼀样，那为该列建⽴索引是没有⽤的，
                因为所有值都⼀样就⽆法排序，⽆法进⾏快速查找了～ ⽽且如果某个建⽴了⼆级索引的列的重复值特别多，
                那么使⽤这个⼆ 级索引查出的记录还可能要做回表操作，这样性能损耗就更⼤了。
                所以结论就是：最好为那些列的基数⼤的列建⽴索引，为基数太⼩列的建⽴索引效果可能不好。

10.索引列的类型尽量⼩: 数据类型越⼩，在查询时进⾏的⽐较操作越快（这是CPU层次的东东）
                       数据类型越⼩，索引占⽤的存储空间就越少，在⼀个数据页内就可以放下更多的记录，从⽽减少磁盘I/O带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从⽽加快读写效率。

11.索引字符串值的前缀：⼀个字符串其实是由若⼲个字符组成，字符串越长占用的存储空间就越大，要在B+树在保存完整的字符串要花费很大的空间，
                       所以只对字符串的前⼏个字符进⾏索引也就是说在⼆级索引的记录中只保留字符串前⼏个字符。
                       因为⼆级索引中不包含完整的字符串信息，所以⽆法对前⼗个字符相同，后边的字符不同的记录进⾏排序，
                       也就是使⽤索引列前缀的⽅式⽆法⽀持使⽤索引排序，只好⽤⽂件排序。

12.让索引列在⽐较表达式中单独出现：如果索引列在⽐较表达式中不是以单独列的形式出现，⽽是以某个表达式，或者函数调⽤形式出现的话，是⽤不到索引的。

13.查询的级别：
    const：SELECT * FROM single_table WHERE id = 1438;
           是常数级别的，代价是可以忽略不计的，只能在主键列或者唯⼀⼆级索引列和⼀个常数进⾏等值⽐较时才有效，
           如果主键或者唯⼀⼆级索引是由多个列构成的话，则索引中的每⼀个列都需要与常数进⾏等值⽐较

    ref:SELECT * FROM single_table WHERE key1 = 'abc';
        搜索条件为⼆级索引列与常数等值⽐较，采⽤⼆级索引来执⾏查询的访问⽅法称为：ref
        对于普通的⼆级索引来说，通过索引列进⾏等值⽐较后可能匹配到多条连续的记录，
        ⽽不是像主键或者唯⼀⼆级索引 那样最多只能匹配1条记录，所以这种ref访问⽅法⽐const差了那么⼀丢丢

    ref_or_null:SELECT * FROM single_demo WHERE key1 = 'abc' OR key1 IS NULL;
                想查询空值，当使⽤⼆级索引⽽不是全表扫描的⽅式执⾏该查询时，这种类型的查询使⽤的访问⽅法就称为ref_or_null

    range:SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 >= 38 AND key2 <= 79);
          把这种利⽤索引进⾏范围匹配的访问⽅法称之为：range

    index:SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';
          这个查询按联合索引的顺序进行查询，并且查询列只用到了联合查询中的列，
          可以直接通过遍历idx_key_part索引的叶⼦节点的 记录来⽐较key_part2 = 'abc'这个条件是否成⽴，
          把匹配成功的⼆级索引记录的key_part1, key_part2, key_part3列的值直 接加到结果集中
          于⼆级索引记录⽐聚簇索记录⼩的多，而且不用回表查询，所以成本要低很多

    all:最直接的查询执⾏⽅式就是全表扫描，对于 InnoDB表来说也就是直接扫描聚簇索引，

14.or  ⼀个使⽤到索引的搜索条件和没有使⽤该索引的搜索条件使⽤OR连接起来后是⽆法使⽤该索引的
       在为某个索引确定范围区间的时候只需要把⽤ 不到相关索引的搜索条件替换为TRUE就好了

15.Intersection索引合并: 合并索引结果集取交集，适⽤于使⽤不同索引的搜索条件之间使⽤AND连接起来的情况
            1）单独根据搜索条件从某个⼆级索引中获取的记录数太多，导致 回表开销太⼤
            2）通过Intersection索引合并后需要回表的记录数⼤⼤减少
   Union索引合并：取并集，适⽤于使⽤不同索引的搜索条件之间使⽤OR连接起来的情况
            1）⼆级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配 部分列的情况
            2）主键列可以是范围匹配
            3）使⽤Intersection索引合并的搜索条件，也就是先Intersection取了交集，再用Union取并集
            优化器在下边两个条件满⾜的情况下才趋向于使⽤Union索引合并：
                单独根据搜索条件从某个⼆级索引中获取的记录数⽐较少
                通过Intersection索引合并后需要回表的记录数⼤⼤减少

16.mysql优化：
    单表查询一条语句的两个成本：IO成本+CPU成本
        IO成本：把数据从内存加载到磁盘消耗的时间称为IO成本
        CPU成本：读取以及检测记录是否满足对应的搜索条件，对结果集进行排序等操作消耗的时间称为CPU成本
    基于成本的优化步骤：
        1.根据搜条件，找出所有可能使用的索引
        2.计算全表扫描的代价
        3.计算使用不同索引查询的代价
        4.选择成本最低的执行方案

    连接查询的成本计算公式是这样的：连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数x单次访问被驱动表的成本
        对驱动表进⾏查询后得到的记录条数称之为驱动表的扇出
        对于左（外）连接和右（外）连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询⽅案只需要： 分别为驱动表和被驱动表选择成本最低的访问⽅法。
        对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个⽅⾯的问题： 不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。
            然后分别为驱动表和被驱动表选择成本最低的访问⽅法。

17.条件化简：
    移除不必要的括号：((a = 5 AND b = c) OR ((a > c) AND (c < 5)))  --》 (a = 5 and b = c) OR (a > c AND c < 5)
    常量传递：a = 5 AND b > a  --》 a = 5 AND b > 5
    等值传递：a = b and b = c and c = 5  --》 a = 5 and b = 5 and c = 5
    移除没用的条件：a = 5 and b = 5 and c = 5  --》  (a < 1 and TRUE) OR (a = 6 OR FALSE) --》 a < 1 OR a = 6
    表达式计算：a = 5 + 1  --》 a = 6
    外连接消除：在被驱动表的WHERE⼦句符合空值拒绝的条件后，外连接和内连接可以相互转换。
                这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执⾏查询。

18.事物的状态：活动的，失败的，部分提交的，中止的，提交的
