判断对象是否已经“死亡的方法”：引用计数法，可达性分析算法

  可达性分析算法：
      用来判断对象是否存活的，通过一系列称为“GC Roots”的对象作为起始点，从这些点开始向下搜索，
      类似于一棵树，当对象到GC Roots没有任何引用链相连时，则说明这个对象是不可达的，也就是不可用的
      不可达对象将会被判定为是可回收的对象

  在java中，可以作为GC Roots的对象有：
      1、虚拟机栈（栈桢中的局部变量表）中引用的对象
      2、方法区中类静态属性引用的对象
      3、方法区中常量引用的对象，如表示类名的字符串
      4、本地方法栈中JNI，即一般说的Native引用的对象

GC算法：
    1、引用记数法：
         是老牌垃圾回收算法，对一个对象A，只要任何对象引用A，则A的计数器就加1，当引用失效时，计数器就减1，只要对象A的
         引用计数器值为0，则A就不可能被引用
         问题：
            1）、引用和去引用伴随加法和减法，影响性能
            2）、很难处理循环引用，即对根对象来说，对象已经是不可达了，但是由于循环引用，对象的计数器不为0，所以不被回收

    2、标记-清除算法：
         ①是现代垃圾回收算法的思想基础，分为两个阶段：标记阶段和清除阶段
         ②在标记阶段，先通过根节点标记所有从根节点开始的可达对象，因此，未被标记的对象就是未被引用的垃圾对象
           在清除阶段，清除所有未被标记的对象，由于只处理未标记的对象，因此会造成内存碎片，即数据在内存中是一块一块的，不统一
         ③碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。
         问题：
            效率问题：标记和清除两个过程的效率都不高
            空间问题：标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中分配较大对象时，
                      无法找到足够的连续内存而不得不提取触发一次GC

    3、标记-压缩算法：
         ①标记过程与“标记-清除”算法一样，然后让所有存活对象都向一端移动，然后直接清理清理掉端边界以外的内存
           标记-压缩算法也要从根节点开始，相当于把存活的对象放到第一排，即解决了内存碎片的问题，然后清除其他所有对象，
         ②标记压缩适用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化，和标记-清除算法一样

    4、复制算法
         ①与标记清除算法相比，是一种相对高效的回收方法，不适用于存活对象较多的场合，如老年代
         ②将原有的内存空间分为两块，每次使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中
           之后清除正在使用的内存块，交换两个内存的角色，完成回收
         ③实际上并不需要按1：1的比例来划分内存空间，而是划分为一个较大的Eden和两块较小的Survivor空间
           每次使用Eden和其中一块Survivor,当GC时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor上
           最后清理掉Eden和刚刚使用的Survivor，如果发现另一块Survivor也满了，对象就会通过分配担保机制直接进入老年代

         问题：①空间浪费，要花费两倍的空间
               ②在对象存活率较高时，需要进行较多的复制操作，效率会降低，如果不想浪费50%的空间，还需要额外的空间进行分配担保
                 以应对被使用的内存中，所有对象都100%存活的极端情况，所以老年代不选择这种算法

    5、分代收集算法
        ①根据对象存活的周期不同，将内存划分为几块，一般把java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法
        ②在新生代中，每次GC时都发现有大批对象死去，只有少量存活，就采用“复制算法”，只需要付出少量存活对象的复制成本就可以完成收集
        ③在老年代中，因为对象存活率高，而且没有额外空间对它进行分配担保，就必须使用“标记-清除”或“标记-压缩”算法

    根据对象的生命周期进行划分，短周期的分为新生代，长周期的分为老年代
    根据不同代的特点，使用不同的垃圾回收算法：
        1）少量对象存活，适合复制算法
        2）大量对象存活，适合标记清除或标记压缩

对象的可触及性
    可触及的：从根节点可以触及到这个对象
    可复活的：一旦所有引用被释放，就是可复活状态，因为在finalize()中可能复活该对象
    不可触及的：在finalize()后，可能会进入不可触及状态，不可触及的对象不可能复活，可以回收，finalize只会执行一次


垃圾收集器

    串行收集器

       1、 Serial收集器
        ①该收集器是单线程的，只会使用一个CPU或一条线程去完成垃圾收集动作，并且在进行收集时，必须要暂停其他所有的工作线程，直到收集结束
          这么做是为了防止一边收集一边产生新对象的情况
        ②最古老，最稳定，简单而高效(与其他收集器的单线程比)，对于限定单个CPU的环境来说，
          Serial收集器由于没有线程交互的开销，所以收集效率高，但是会产生较久的停顿
        ③使用复制算法
        -XX:+UseSerialGC
        新生代、老年代使用串行回收
        新生代复制算法，老年代标记-压缩

       2、 Serial Old收集器
        是Serial收集器的老年代版本，也是一个单线程收集器，使用“标记-整理”算法

    并行收集器

        3、ParNew 收集器
            ①该收集器是Serial收集器的多线程版本，基本与Serial完全一样，除了使用多条线程进行垃圾收集
              目前只有该收集器和Serial收集器能与CMS收集器配合工作
            ②使用复制算法
            新生代并行，老年代串行
            多线程，需要多核支持
            -XX:+UseParNewGC，强制指定使用该收集器
            -XX:ParallelGCThreads 限制垃圾收集线程的数量

        4、Parallel Scavenge收集器
            ①是一个新生代收集器，使用复制算法
            ②关注吞吐量，吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，吞吐量越高，就可以更有效的利用CPU时间
            参数：
                -XX:MaxGCPauseMills：值大于0的毫秒数，收集器尽可能保证内存回收的时间不超过设定值，也就是最大停顿时间
                                     但是GC停顿时间是以牺牲吞吐量和新生代空间来换取的，系统把新生代调小些，则垃圾收集就更为频繁，
                                     这样停顿时间确实下降了，但是吞吐量也下降了
                -XX：GCTimeRatio:是一个大于0小于100的整数，也就是垃圾时间占总时间的多少，相当于是吞吐量的倒数，默认99，即最大允许1%时间做GC
                                 这两个参数是矛盾的。因为停顿时间和吞吐量不可能同时调优，
                                 停顿久就证明吞吐量低，所以不可能停顿时间长而吞吐量高的
                -XX:UseAdaptiveSizePolicy:当打开时，就不需要手工指定新生代的大小（Xmm），Eden与Survivor的比例（SurvivorRatio）等细节参数
                                          虚拟机根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或吞吐量
                                          这种调节方式叫做GC自适应的调节策略
                                          只要把基本内存数据设置好（Xmx），再设置前面两个参数其中一个，给虚拟机设立一个优化目标
                                          那具体参数调节工作就由虚拟机完成了
            类似ParNew
            新生代复制算法，老年代 标记-压缩
            更加关注吞吐量
            -XX:+UseParallelGC
            使用Parallel收集器+ 老年代串行
            -XX:+UseParallelOldGC
            使用Parallel收集器+ 并行老年代

        5、Parallel Old收集器
            ①该收集器是Parallel Scavenge收集器的老年代版本，是多线程的，使用“标记-整理”算法
            ②在注重吞吐量和CPU资源敏感的场合，都可以考虑Parallel Scavenge和Parallel Old收集器

       ★6、CMS收集器:以获取最短停顿时间为目标的收集器
            Concurrent Mark Sweep 并发记标清除
            1）使用标记-清除算法               ？？//与标记-压缩相比，并发阶段会降低吞吐量
            2）CMS运行过程比较复杂，着重实现了标记的过程，可分为
              ①初始标记：标记GC Roots可以直接关联到的对象，速度快
              ②并发标记（和用户线程一起）：主要标记过程，通过可达性分析，标记全部对象
              ③重新标记：由于并发标记时，用户线程依然运行，可能会导致标记产生变动，因此在正式清理前，再做修正。速度比初始标记慢
              ④并发清除（和用户线程一起）：基于标记结果，直接清理对象
              这四个过程中并发标记和并发清除耗时最长

            老年代收集器（新生代使用ParNew）
            -XX:+UseConcMarkSweepGC

                优点：
                    并发收集，低停顿（高吞吐量）
                缺点：
                    ①对CPU资源非常敏感
                        在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程导致程序变慢，总吞吐量降低
                        当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降
                        当CPU不足4个时，CPU对用户影响就可能很大
                        比如CPU负载本来就很大，在用户线程运行过程中，还分一半CPU去做GC，系统性能在GC阶段，反应速度就下降一半
                    ②无法清理浮动垃圾
                        清理不彻底，因为在清理阶段，用户线程还在运行，会产生新的垃圾，也就是浮动垃圾
                        这部分垃圾在标记后才出现，所以无法在当次收集中清理它们，只能等下一次GC
                        也是由于垃圾收集阶段用户线程还需运行，所以也就需要预留足够的空间给用户线程使用，
                        因此不能等到老年代几乎快满时再进行收集，需要预留一部分空间提供并发收集时的程序使用
                        可以通过 -XX:CMSInitiatingOccupancyFraction设置触发GC的阈值，默认是92%，不过不能设置得太高
                        如果不幸内存预留空间不够，就会引起concurrent mode failure
                        此时虚拟机就会启动后备预案：临时用Serial Old收集器来进行老年代的垃圾收集，这样停顿时间就很长了
                    ③会产生大量空间碎片
                        因为使用“标记-清除”算法，所以会有大量空间碎片产生，碎片过多时，会给大对象分配带来麻烦
                        老年代就会出现空间剩余。却无法找到足够大的连续空间分配对象而提前触发一次FULL GC的情况
                        可以设置UseCMSCompactAtFullCollection，用于设置在进行FULL GC时进行一次碎片的合并整理，
                        整理的过程是独占的，会引起停顿时间变长

                参数
                    -XX:+CMSFullGCsBeforeCompaction
                    设置进行几次Full GC后，进行一次碎片整理，默认是0
                    -XX:ParallelCMSThreads
                    设定CMS的线程数量

       ★7、G1收集器
            1）与其他收集器相比的优点：
                ①并行与并发：G1能充分利用多CPU，多核环境下的优势，缩短STW停顿的时间，部分其他收集器需要停顿java线程执行GC，
                              G1可以通过并发的方式让程序继续运行
                ②分代收集：G1可以独立管理整个GC堆，也可以采用不同的方式去处理新对象和已经存活了一段时间，经过多次GC的对象
                ③空间整合：G1从整体看是用“标记-整理”算法，从局部（两个Region）看是“复制”算法
                            但是两种算法都意味着G1不会产生内存碎片，这有利于程序长时间运行
                            分配对象时不会因为找不到连续空间而提取触发下一次GC
                ④可预测的停顿：G1可以建立可预测的停顿时间模型，能指定在M毫秒时间内，GC的时间不得超过N毫秒
            2）使用G1时，会把java堆划分为多个相等的独立区域（Region），这样新生代和老年代就不是物理隔离的了，是一部分Region的集合
            3）G1可以有计划的避免在整个java堆中进行垃圾收集。它会跟踪各个Region里的垃圾堆积的价值大小（回收后获得的空间/回收所需时间的经验值）
               在后台维护一个优先列表，优先回收价值最大的Region，保证了在有限时间内可以获取尽可能高的收集效率
            4）在G1中，Region间的对象引用和其他收集器中新生代和老年代间的对象引用，虚拟机是使用Remembered Set来避免全堆扫描的
               每个Region都有一个RS，程序在对引用类型的数据进行写操作时，虚拟机会暂时中断写操作，检查引用的对象是否在不同的Region
               在分代中就是检查老年代是否引用了新生代的对象，如果是就通过CardTable把相关引用信息记录到被引用对象的RS中，
               当进行内存回收时，在GC Roots的枚举范围内加入RS即可保证不对全堆扫描
            5）GC运作的过程：
                ①初始标记：标记GC Roots能直接关联到的对象，并且修改TAMS的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建对象
                            需要停顿，耗时短
                ②并发标记：从GC Roots中进行可达性分析，找出并标记存活对象，耗时长，但是可与用户程序并发进行
                ③最终标记：修正在并发标记期间用户程序继续运行而导致标记产生改变的一部分标记记录，虚拟机将变化记录在RS Logs中，
                            最后需要把RS Logs的数据合并到RS中，需要停顿，但是可并发进行
                ④筛选回收：先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，
                            这里虽然可以并发执行，但是只回收一部分Region，时间是用户可控的，而且停顿用户线程将大幅度提高收集效率


    新生代收集器：Serial, ParNew,Parallel Scavenge
    老年代收集器：Serial Old,Parallel Old, CMS
    吞吐量收集器用于中大型应用程序
    串行收集器用于小型应用程序

内存回收与分配策略
    新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为java对象大都具备朝生夕灭的特性，所有Minor GC非常频繁，一般速度也比较快
    老年代GC（FULL GC）：指发生在老年代的GC，出现了Major GC，大多数情况会伴随至少一次的Minor GC（非绝对）
                         速度比Minor GC慢10倍以上

    1、对象优先在Eden分配
        大多数情况下，对象在新生代Eden区中分配，当Eden中没有足够空间时，虚拟机会发生一次Minor GC
        会把Eden中存活的对象放到Survivor中，如果Survivor空间不足，则会放到老年代中

    2、大对象直接进入老年代
        所谓的大对象是指需要大量连续内存空间的java对象，比如很长的字符串和数组
        经常出现大对象容易导致内存还有不少空间就提前触发GC
        可以通过-XX:PretenureSizeThreshold 设置指定大小的对象直接进入老年代

    3、长期存活对象将进入老年代
        为了识别对象应放在什么地方，虚拟机给每个对象都定义了一个对象年龄计数器
        如果对象在Eden出生并经过第一次Minor GC后仍然存活，并能够被Survivor容纳，就将被移动到Survivor中，并且对象年龄设为1
        后面对象在Survivor区中每经过一次Minor GC并存活，年龄就增加1，当达到阀值后，就会被存到老年代
        对于阀值可以通过MaxTenuringThreshold来设定

    4、动态对象年龄判定
        如果在Survivor中相同年龄所有对象大小的总和大于Suvivor的一半，年龄大于或等于该年龄的对象就可以直接进入老年代

    5、空间分配担保
        在发生Minor GC前，虚拟机会先检查老年代最大的连续空间是否大于新生代对象所有空间，如果是，那么Minor GC可以保证是安全的，
        如果不是会检查老年代最大可用的连续空间是否大于历次晋级到老年代对象的平均大小，如果是就进行Minor GC，否则进行Full GC

    GC参数整理aaa
        -XX:+UseSerialGC：Serial + Serial Old
        -XX:+UseParNewGC：ParNew + Serial Old
        -XX:+UseParallelGC ：Parallel Scavenge + Serial Old
        -XX:+UseParallelOldGC：Parallel Scavenge + Parallel Old
        -XX:+UseConcMarkSweepGC：ParNew + CMS + Serial Old
        -XX:CMSInitiatingOccupancyFraction：设置CMS收集器在老年代空间被使用多少后触发,默认68%
        -XX:+UseCMSCompactAtFullCollection：设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片的整理
        -XX:CMSFullGCsBeforeCompaction：设定进行多少次CMS垃圾回收后，进行一次内存压缩
        -XX:+CMSClassUnloadingEnabled：允许对类元数据进行回收
        -XX:CMSInitiatingPermOccupancyFraction：当永久区占用率达到这一百分比时，启动CMS回收
        -XX:UseCMSInitiatingOccupancyOnly：表示只在到达阀值的时候，才进行CMS回收
        -XX:ParallelCMSThreads：设定CMS的线程数量
        -XX:NewRatio:新生代和老年代的比
        -XX:ParallelGCThreads：设置用于垃圾回收的线程数
        -XX:SurvivorRatio：设置eden区大小和survivior区大小的比例,默认是8：1
        -XX:PretenureSizeThreshold:大于设定值的对象直在老年代分配，只对Serial和ParNew有效
        -XX:MaxTenuringThreshold：设置新生代对象最多经过多少次进入老年代