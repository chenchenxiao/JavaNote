设计原则：
    1、找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
    2、针对接口编程，而不是针对实现编程
    3、多用组合，少用继承
    4、为了交互对象间的松耦合设计而努力
    5、类应该对扩展开放，对修改关闭（开闭原则）
    6、要依赖抽象，不要依赖具体类（依赖倒置原则）
    7、减少对象间的交互，只留下几个“密友”（最少知识原则）
           实现：1、只调用该对象本身的方法6
                 2、只调用被当作方法参数而传递进来的对象
                 3、只使用此方法创建或实例化的对象
                 4、只调用对象的足见（也就是对象所引用的对象）
    8、别调用我们，我们会调用你。
       即允许低层组件挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件
    9、一个类应该只有一个引起变化的原因（单一责任）

策略模式：
    eg: void eat(Anmail anmail)(){}
    在使用时根据所需传入不同的Anmail子类实例，同一行为有不同的实现

观察者模式：
    在对象之间定义一对多的依赖，当一个对象改变时，依赖它的对象都会收到通知，并自动更新

装饰者模式：
    动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案

工厂方法模式：
    定义了一个创建对象的接口，但由子类决定要实例化的是哪一个，工厂方法让类把实例化推迟到子类
    使用的是继承的方式

抽象工厂模式：
    提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类
    定义一个负责创建一组产品的接口，接口内的每个方法都负责创建一个具体产品
    抽象工厂的方法经常以工厂方法的方式实现
    使用的是组合的方式

单例模式：
    确保一个类只有一个实例，并提供一个全局访问点

命令模式：
    将“请求”封装成对象，以便使用不同的请求队列或者日志来参数化其他对象，命令模式也支持可撤销的操作

适配器模式：
    将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间

外观模式：
    提供了一个统一的接口，用来访问子系统中一群接口。外观定义了一个高层接口，让子系统更容易使用

模板方法模式：
    在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些逻辑

迭代器模式：
    提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示

组合模式：
    允许将对象组合成树状结构来表示“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合