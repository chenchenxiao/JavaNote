

# 1.为什么会有TIME_WAIT,什么情况下会出现大量TIME_WAIT,怎么解决？

![image-20190908204619680](/Users/pangxinyu/Documents/每日学习文稿/面经和面试准备/md图库/image-20190908204619680.png)

time_wait是主动发起关闭端，在接收到被发起关闭端的ack之后，回复确认之后进入的阶段。

发起断开连接的端很多的时候，会出现大量time_wait。

服务器发送了FIN-ACK之后，会立即启动超时重传计时器(如果一直丢失，在LAST_ACK时间后，服务端会自动断开（时间多长，可以调节））。

> 🍎：LAST_ACK:
>
> 被动关闭方进入LAST_ACK状态后，假设一直没有收到最后一个ACK，会一直重传FIN，一直重传次数到达TCP_RETRIES2(默认值是15，一般可以设置为3或以上，根据业务需要的检测到死连接的时间设置）时放弃，将这个时间定义为「被动关闭方LAST_ACK的超时时间」，接着必须等待最后一个重传的FIN失效，需要一个MSL的时间。这样才能保证所有重传的FIN包失效，不干扰新连接吧。

客户端在发送最后一个ACK之后会立即启动时间等待计时器（time_wait一般等于两个MSL，MSL是最长报文段寿命，建议值是2分钟，可以使本连接持续的时间内所产生的所有报文段都从网络中消失)。

如果客户端一直等不到FIN_ACK在FIN_WAIT2（TCP/IP协议栈没有设置FIN_WAIT2超时，需要自己设置）之后就会自动断开。

```
net.ipv4.tcp_fin_timeout = 30
//表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。
```

```
net.ipv4.tcp_max_tw_buckets = 5000
//表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。默认为180000，改为 5000。
```

# 2.B+树和B树的使用场景，面试一下B+

B+树和B树最大的区别是，B+树非叶子结点只存储key，（叶子结点存储key和value），而B树每一个结点都存储Key和value。

**B+非叶子节点并不存储行数据，是为了能存储更多索引键，从而降低B+树的高度，进而减少IO次数。**

1. B+树索引并不能直接找到行，只是找到行所在的页，通过把整页读入内存，再在内存中查找。
2. 索引的B+树高度一般为2-4层，查找记录时最多只需要2-4次IO。

中间节点和叶子节点存储：B+树所有指向文件多关键字及其指针都在叶子节点中，B树所有指向文件的关键字是在内部节点中。B+树中，内部节点仅仅起到索引的作用。

搜索：B树只要命中的就搜索结束（不稳定），B+树要搜索到叶子节点（稳定，且不慢），B+在搜索过程中，如果查询和内部节点的关键字一致，那么搜索过程不停止，而 是继续向下搜索这个分支，B+为了找到这个关键字的指针。 

B树在提高IO性能的同时，并没有解决**元素遍历时效率低下**的问题，正是为了解决这个问题，B+数应运而生。**B+数只需遍历叶子节点即可实现整棵树的遍历，而B树必须使用中序遍历按序扫库，B+树支持范围查询非常方便。这才是数据库选用B+树的主要原因。**

另外，最后说一下，并不是说B+树就比B树好，有很多基于频率的搜索是选用B树，越频繁query的结点越往根上走，前提是需要对query做统计，而且要对key做一些变化。 
无论是B树还是B+树由于前边几层反复query，因此早已被加载入内存，不会出现读磁盘IO。一般启动的时候，就会主动换入内存。在内存中B+树并没有优势，只有在磁盘中B+树的威力才能显现。

B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让**查询速度更加稳定**，其速度完全接近于二分法查找。





# 3.从文件里的百万数据，获取前1000个最大数据？

10个或20个线程（取硬盘里读数据），顺序写入堆（在内存中操作，所以速度很快）

大小为1000的最小堆，遍历一遍，往里面灌数据（取前100个最小的是用最大堆，取前1000个最大的是用最小堆）

# 4.将无序数组转成有序数组，数据量特别大的情况下，如何实现

<https://www.cnblogs.com/LUO77/p/5838206.html#targetText=%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E6%8C%87%E7%9A%84%E6%98%AF,%E8%BF%9B%E8%A1%8C%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E3%80%82>

🍎：主要的限制其实是内存，一次性装不下这么多数据

核心：多路归并排序，流式输入

> 🍎外部归并排序
>
> **外部排序**指的是大文件的**排序**，即待**排序**的记录存储在外存储器上，待**排序**的文件无法一次装入内存，需要在内存和**外部**存储器之间进行多次数据交换，以达到**排序**整个文件的目的。 **外部排序**最常用的算法是多路**归并排序**，即将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成**排序**。 然后，对已经**排序**的子文件进行多路**归并排序**。

先把数据分块，比如十万一块，把每快先排好序，然后多路归并排序。

用堆维护每个文件最小的值，把堆中最小的输出，然后从它对应文件再读一个数，重复这个过程直到没数据。



# 5.中断

中断是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。

中断的本质是轮询。CPU会通过读取外部信号来判断CPU的下一步状态。CPU在每个指令周期，在执行完指令之后，会去查看中断寄存器的状态，如果有中断，那么就跳转到中断处理程序。

CPU处理器的引脚中，有一个pin专门用于接受中断请求，这个引脚是INTR pin。

> CPU执行完一条指令后，下一条指令的逻辑地址存放在cs和eip这对寄存器中。在执行新指令前，控制单元会检查在执行前一条指令的过程中是否有中断或异常发生。如果有，控制单元就会抛下指令，进入下面的流程：
>
> 1. 确定与中断或异常关联的向量i (0£i£255)
>
> 2. 寻找向量对应的处理程序
>
> 3. 保存当前的“工作现场”，执行中断或异常的处理程序
>
> 4. 处理程序执行完毕后，把控制权交还给控制单元
>
> 5. 控制单元恢复现场，返回继续执行原程序



# 7.进程调度策略 

**1.先来先服务调度算法**

**2.短作业优先调度算法**

**3.高优先权优先调度算法**

**4.高响应比优先调度算法**：在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：

**5.时间片轮转法**

**6.多级反馈队列调度算法**（就是靳海龙做的java ui界面的那个）

(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。

(2)当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。

(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。

🍎批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？
批处理系统常用调度算法：
①、先来先服务：FCFS
②、最短作业优先
③、最短剩余时间优先
④、响应比最高者优先

分时系统调度算法：
①、轮转调度
②、优先级调度
③、多级队列调度
④、彩票调度

实时系统调度算法：
①、单比率调度
②、限期调度
③、最少裕度法

# 8.osi主要协议，telnet哪一层 

![image-20190826174045310](/Users/pangxinyu/Documents/每日学习文稿/面经和面试准备/md图库/image-20190826174045310.png)

telnet位于应用层

# 9.死锁的产生原因，如何预防 

由于两个或多个事务都已经封锁了一些数据对象，然后又请求已经被事务锁住的数据，这些事务永远都不能结束，就形成了死锁。

产生死锁的必要条件：4个

互斥条件

不可抢占条件

占有且申请条件

循环等待条件

## 死锁预防：

1.打破互斥条件。即允许进程同时访问某些资源

2.打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。

3.打破占有且申请条件。可以实施资源预先分配策略，即进程运行前一次性请求它所需要的所有资源。

主要问题是：许多情况下一个进程在执行前不可能知道它所需要的全部资源吗这是由于进程在执行时是动态的，不可预测的。

资源利用率低。无论所分资源何时用到，一个进程只有在占有所需的全部资源后才能执行，即使这些资源最后才使用一次，但进程生存期间却一直占用他们，造成长期占着不用的情况，这是一种极大的资源浪费。

降低进程的并发性。因为资源有限，加上存在浪费，能分配到所需全部资源的进程个数必然少了。

## 死锁避免

### 安全序列

安全序列是指对当前申请资源的进程排出一个序列，保证按照这个序列分配资源完成进程，不会发生“酱油和醋”的尴尬 问题。 

我们假设有进程 P1,P2,.....Pn
 则安全序列要求满足:Pi(1<=i<=n)需要资源<=剩余资源 + 分配给 Pj(1 <= j < i)资源 为什么等号右边还有已经被分配出去的资源?想想银行家那个问题，分配出去的资源就好比第二个开发商，人家能还回 来钱，咱得把这个考虑在内。 

### 银行家算法

为保证资金的安全，银行家规定:

(1) 当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客; 

(2) 顾客可以分期贷款，但贷款的总数不能超过最大需求量; 

(3) 当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间 里得到贷款; 

(4) 当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金. 

操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量， 如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请 资源时，先测试该进程本次申请的资源数是否超过了该资源所剩余的总量。若超过则拒绝分配资源，若能满足则按当前 的申请量分配资源，否则也要推迟分配。 



# 15.redis如何保证和db的一致性 

redis和db保证数据一致性应该是由业务逻辑去保证的

1. 读。假如redis里无数据&过期，到db里查，再写入redis。
  2.写。 先写db，然后再写redis。

# 16.算法 求二叉树深度 不用递归



# 17.消息队列如何保证顺序性

队列：rabbitMq

在mq里面创建多个queue，同一规则的数据（对唯一标识进行hash），有顺利的放入mq的queue里面，消费者只取一个queue里面获取数据消费，这执行的顺序是有序的。或者还是只有一个queue但是对应一个消费者，然后这个消费者内部使用**内存队列**做排队，然后分发给底层不同的worker来处理。

q：什么是**内存队列**？

![image-20190822173749311](/Users/pangxinyu/Documents/每日学习文稿/面经和面试准备/md图库/image-20190822173749311.png)

队列：kafka

在 kafka 中，你对数据指定某个 key，那么这些数据会到同一个 partition 里面（类似rabbitMq的queue），在partition里的数据是有序的。

但消费者端可能会使用多线程来处理，因为单线程的处理速度慢，为了加快处理时间和吞吐量，会使用线程来处理。在消费端加入线程后会出现顺序不一致的情况。

解决办法：在消费端使用内存队列，队列里的数据使用 hash 进行分发，每个线程对应一个队列，这样可以保证数据的顺序。



# 别人美团的一面

Q：先做个简单的自我介绍吧 

Q：说说你项目的一些功能特点以及实现方式还有实现难点等。 

Q：讲一讲Redis的特性，redis为什么快，redis你用了哪些数据结构，粉丝列表可以用 

redis存储吗，redis集群会配置吗，redis宕机后数据会消失吗，redis可以持久化吗，怎么持久化。 

Q：登录功能考虑过安全问题吗，你怎么解决的。 

Q：密码采用哪种加密方式（MD5），你为什么要用这种方法，这种方式有不安全的地方，你会怎么解决它。 

Q:数据库索引有了解吗，你这个项目用了索引吗，用在了哪张表，为什么要用索引，索引快在哪里，**事务隔离级别，传播方式**这些介绍下。 



Q：用户量增多了怎么办，服务器压力太大了你会用什么方式，数据库呢，遇到高并发呢，你会改变表结构吗。 

Q:你觉得你哪方面熟悉点，JVM,数据结构，算法，Java基础，集合框架，我们可以深入探讨一下（脑子短路说的JVM，怼到心态爆炸） 

Q：看过哪些源码，（hashmap，concurrenthashmap，hashtable），那你说说各自的特点。（把concurrenthashmap和hashtable说混了，面完了才想起） 

Q：学习方式（前期视频，中期开始看书） 

Q：分布式系统又了解吗，分布式的特点，你会怎么搭建分布式系统，集群了解吗，集群的优点讲讲，你会怎么用集群。 

Q：负载均衡了解吗，如果让你实现负载均衡你会使用哪种方法，为什么要用这种方法，其他方式又了解过吗，各自方式的特点。 

Q：项目的JS和AJAX也是自己写的吗，介绍下你是如何开发前后端的 

Q：链表反转写下代码吧（写出来就过，脑子一团浆糊挣扎了一会儿就放弃了）。

 

**面试官一直往高可用， 高并发，高性能上怼。**
