我们都知道jvm运行时刻内存的分配。其中有一个内存区域是jvm虚拟机栈，
每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。
当线程访问某一个对象的值的时候，首先通过对象的引用找到对应在堆内存的变量的值，
然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，
之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，
在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了

JVM中，内存的分配方式有：
    动态内存分配； 只有在程序执行时才知道要分配的内存的大小，比如对象引用
    静态内存分配： 在编译时就能确定要分配的空间的大小，比如类和方法的局部变量和原生数据类型，对象的引用

JVM在java程序执行时会把内存分为若干个数据区
    1、线程私有区域：本地方法栈，虚拟机栈，程序计数器
    2、线程共享区域：方法区，堆

   1）程序计数器：
                  ①是一块较小的内存空间，保存着当前线程所执行程序的字节码指令地址，字节码解释器通过改变这个计数器的值来选择下一条要执行的指令
                    例如：分支，循环等，都需要依赖程序计数器。

                  ②如果该线程正在执行的是一个java方法，计数器记录的就是正在执行的虚拟机字节码指令地址；
                    如果是本地方法，则计数器为空(Undefined)

                  ③该区域是java虚拟机规范中唯一一个不会出现OOM情况的区域

   2）虚拟机栈：
                  ①描述的是java方法执行时的内存模型，生命周期与线程相同；每个方法在执行时都会创建一个栈桢，
                    栈桢用于存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法从调用到方法结束的过程，
                    就意味着一个栈桢在虚拟机中入栈到出栈的过程

                  ②平时所说的“堆和栈”，一般“栈”指的就是虚拟机栈；

                  ③局部变量表存放了编译期可知的8大基本数据类型(long、double占两个局部变量空间)，和对象引用（对象地址）、和下一条字节码指令的地址
                    在进入一个方法时，需要在栈桢上创建多大的局部变量空间是完全确定的，方法运行时不会发送改变其大小

                  ④在java虚拟机规范中，对该区域规定了两种异常情况：
                      1、如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError
                      2、如果虚拟机栈扩展时无法申请到足够的内存，将抛出OOM

   3）本地方法栈：
                  与虚拟机栈非常相似，区别就是虚拟机栈是为java方法服务，而本地方法栈是为Native方法服务，
                  在HotSpot虚拟机中，把虚拟机栈和本地方法栈合在了一起

   4）堆：
                  ①堆是java虚拟机所管理的内存中最大的一块，在虚拟机启动时创建，该区域的唯一作用就是存放对象实例

                  ②java堆是垃圾收集器管理的主要区域，从内存回收的角度来看，因为收集器大都采用分代收集算法
                    所以java堆可以分为：新生代和老年代，再细致点可以分为Eden，Form Survivor，To Survivor空间
                    从内存分配角度老看，java堆可能划分多个线程私有的分配缓存区，划分的目的都是为了更高的回收内存，
                    或者更快的分配内存。存储的仍然是对象实例

                  ③java堆可以处于物理上不连续的内存空间中，只要逻辑是连续的即可，在实现时，即可以是固定大小，也可以是可扩展的
                    如果堆中没有内存可以分配实例并且堆也无法扩展时，将抛出OOM

   5）方法区：
                  ①用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据

                  ②和堆一样不需要连续的内存空间和可以选择固定大小或可扩展，还可以选择不实现垃圾收集

                  ③相对来说，垃圾收集在该区域比较少出现，该区域的内存回收目标主要是针对常量池回收和对类型的卸载
                    类型的卸载条件比较苛刻，但是这部分区域的回收确实是必要的

                  ④当方法区无法满足内存分配需求时，会抛出OOM

   6）运行时常量池：
                  ①该区域是方法区的一部分，Class文件中的信息除了类的字段，方法，接口等信息外，还有一项信息是常量池，
                    用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入该区域中存放，
                    还会把翻译出来的直接引用也存储到该区域中
                    符号引用：类和接口的全限定名、方法的名称和描述、字段的名称和描述

                  ②运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，在java中不要求常量只有在编译期才能产生，
                    也并非预置入Class文件常量池的内容才能进入运行时常量池，运行期间也可能将新的常量放入，例如String.itern()方法

                  ③当常量池无法再申请到内存时，会抛出OOM

   7）直接内存：
                  ①该区域不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，
                    在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，
                    它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。
                    这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据

                  ②NIO的Buffer提供一个可以直接访问系统物理内存的类——DirectBuffer。
                    DirectBuffer类继承自ByteBuffer，但和普通的ByteBuffer不同。普通的ByteBuffer仍在JVM堆上分配内存，其最大内存受到最大堆内存限制
                    而DirectBuffer直接分配在物理内存中，并不占用堆空间。在访问普通的ByteBuffer时，系统总是会使用一个“内核缓冲区”进行操作。
                    而DirectBuffer所处的位置，就相当于这个“内核缓冲区”。
                    因此，使用DirectBuffer是一种更加接近内存底层的方法，所以它的速度比普通的ByteBuffer更快。

                  ③服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，
                    但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），
                    从而导致动态扩展时出现OutOfMemoryError异常。

   以上都是对于java1.8以前的，1.8之后的改动：
    1.移除了永久代(方法区)，替换为元空间（在本地内存中，大小受本地内存影响）
    2.永久代中的class metadata转移到了本地内存中
    3.永久代中的字符常量和静态属性转移到了java堆中

    这么做的原因：永久代很难确定大小，难调优，涉及到类的总数，常量池大小和方法数量等，而且永久代数据会随着每一次full GC而发生变动
    而在1.8后，类的元数据存在本地内存中，元空间的最大空间就是系统可用内存空间，可以避免永久代的内存溢出问题。