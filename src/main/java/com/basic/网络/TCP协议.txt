序列号seq:占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个符号，第一个字节的编号由本地随机产生，
          给字节编上序号后，就给每一个报文段指派一个序号，seq就是这个报文段中的第一个字节的数据编号
确认号ack:占4个字节，期待收到对方下一个报文段的第一个数据字节的序号，序列号表示报文段携带数据的第一个字节的编号，
          而确认号指的是期望接收到下一个字节的编号，因此当前报文段最后一个字节的编号+1即为确认号ack
确认ACK:占1位，仅当ACK=1时，确认号字段才有效，ACK=0时，确认号无效
同步SYN: 连接建立时用于同步序号，当SYN=1，ACK=0时表示这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1,ACK=1。
         因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN只有才TCP建产连接时才会被置为1，握手完成后SYN被置为0
终止FIN: 用来释放一个连接。FIN=1表示此报文段的发送方已经发送完毕，并要求释放运输连接


三次握手
第一次握手：客户端发送 syn 包 (syn=x) 到服务器，并进入 SYN_SEND 状态，等待服务器确认；
第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=x+1），同时自己也发送一个 SYN 包（syn=y），
            即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；
第三次握手：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK(ack=y+1)，
            此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。
握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。
理想状态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。


四次挥手
客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（报文段4）。
服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。
服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）。
客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。

问题1 ： 为什么是三次握手而不是两次
    ①如果只需要两次握手就能建立连接，A第一次发送数据报给B时，B没有收到SYN，A第二次发送时B收到了SYN，返回ACK，A收到ACK后建立连接，
      数据传输完，连接断了之后，第一次发送的SYN突然到达了B，B会认为这是A发送的一次新的请求，返回ACK后建立连接，但实际上A并没有发出请求，
      A此时收到一个号莫名的ACK数据报，不会做任何处理，B就在那一直等待A发送数据。
    ②还有一种情况，A发送大量请求给B，B收到了，回复ACK时A却没收到，但是B此时已经认为连接已经建立好了，会往A发送数据，但是A没有收到ACK，认为连接没建立，
      会无视B的数据，一直等待接收ACK，这样就形成了死锁

问题2：为什么三次握手而不是四次
    因为服务器端在返回ACK时，在同一个数据报里，加上了自己的SYN数据，所以把这两个数据封装在了同一个数报里

问题3：为什么是四次挥手
    TCP的数据传输是全双工的，单方面关闭并不影响对方向自己发送数据，因此，A发送FIN包给对方，表示我这边没有数据了，对方回复ACK。表示不会再接收A发送的数据
    B再发FIN包给A，A回ACK表示确认，此时TCP才是在两边真正关闭，如果A发送FIN给B时，B也没有数据发送给A的话，其实可以在一个数据包里把FIN包和ACK都发给A的，这样就能三次关闭链接

问题4：如果遇到了SYN Flood攻击该如何防御
    SYN Flood就是在三次握手中，攻击者大量的发送SYN报文，服务端将为了维护一个非常大的半连接列表而消耗非常多的资源
    防御方式：
        1、无效连接监视释放：不停监视系统的半连接和不活动连接，当到达一定阀值时拆除这些连接，从而释放系统资源
        2、延缓TCB分配方法，因为消耗服务器端资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源，
           因此，当正常连接建立起来后再分配TCB则可以有效减轻服务器端资源的消耗，技术有Syn Cache和Syn Cookie

        3、使用SYN Proxy防火墙，防火墙提供一种SYN代理的功能，主要原理是对试图穿越的SYN请求进行验证后才放行

问题5、为什么TIME_WAIT状态需要经过2MSL才能回到CLOSE状态
       ① 保证TCP协议的全双工连接能够可靠关闭
          如果客户端直接CLSOED，那么IP协议的不可靠性或者是其他网络原因，导致服务端没有收到最后ACK。
          服务端就会在超时后继续发FIN，由于Client已经关闭了，就找不到与重大的FIN对应的连接，服务端最后会收到RST，
          服务端会以为是连接错误，把问题报告给高层，这样虽然不会丢失数据，却导致TCP不符合可靠连接的要求
       ② 保证这次连接的重复数据段从网络中消失
          如果客户端直接关闭，然后又再向服务端发起一个连接，有可能新连接和老连接的端口号是想相同的，假设新老连接的端口相同，
          如果前一次连接的数据仍然滞留在网络中，这些数据在建立新连接之后才到达服务端，由于端口是一样的，又因为TCP协议判断不同连接的依据是socket pair,
          TCP就会认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生了混淆，所以TCP连接还要在TIME_WAIT状态等待2倍MSL，
          这样可以保证本次连接的所有数据都从网路中消失

问题6、如何解决流量控制和拥塞控制的问题
        通过滑动窗口的机制来解决流量控制问题：滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送自己的窗口大小，从而控制发送方的速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的
        解决拥塞控制的问题：
            ① 慢开始算法：当主机开始发送数据时，如果立即发送大量数据网络，就有可能引起网络拥塞。可以先测探一下，由小到大逐渐增大发送窗口。可以使分组注入到网络的速率更加合理
                           慢开始算法是以指数的形式增长的，所以有可能会突然的导致网络拥塞，所以一般会设置一个门限值
            ② 拥塞避免算法：让拥塞窗口缓慢地增大，每次都只让cwnd加1，而不是加倍，比慢开始的增长速率要缓慢很多
            当cwnd < 门限值  使用慢开始算法
            当cwnd > 门限值  使用拥塞避免算法
            当cwnd = 门限值  两个方法都可以使用
            无论是慢开始还是拥塞避免算法，只要发送方判断网络出现拥塞（其根据就是没有收到ACK），就要把门限值设置为拥塞时发送窗口的一半，
            然后把拥塞窗口重新设置为1，执行慢开始算法，这样做是为了迅速减少主机发送到网络中的分组数，使得发省拥塞的路由器有足够时间把队列中积压的分组处理完毕
            ③ 快重传和快恢复： 快重传算法要求接收方没收到一个失序的报文段后就立即发出重复确认（为的是让发送方及早知道有报文没有到达对方）而不要等到自己发送数据时才进行捎带确认
               与快重传配合使用的有快恢复算法：
                   1、当发送方连续收到三个重复确认，就执行“乘法减小”算法，把门限减半，这是为了预防网络发生拥塞，但是接下去不执行慢开始算法
                   2、由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口现在不设置为1），而是把cwnd值设置为慢开始门限减半后的数值，
                      然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。

问题7、TCP是如何保证传输的可靠性
        通过顺序编号和确认号（ACK）还有超时重传来保证

问题8、如何理解UDP无连接
        指通信双方不需要实现建立一条通信线路，而是把带有目的地址包送到线路上，由系统自主选定线路传输

问题9、TCP与UDP的区别
    TCP能保证数据的可靠传输和顺序，而UDP不能，UDP可能会丢包
    TCP对系统资源需求高，UDP较低
    UDP的程序结构比较简单
