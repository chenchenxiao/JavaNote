线程调度
    协同式调度：
        线程的执行时间由线程本身来控制，线程把自己的工作执行完之后，要主动通知系统切换到另一个线程上
        好处：实现简单，线程要自己的事情干完后才进行线程切换，切换操作对自己是可知的，所有没有线程同步问题
        坏处：线程执行时间不可控，如果线程编写有问题，一直不告知系统进行线程切换，那程序就会一直阻塞
    抢占式调用：
        每个线程将由系统来分配时间，线程的切换不由线程本身决定，线程的时间是可控的，不会有一个线程导致整个进程阻塞的问题
        java用的就是抢占式调用


1、在Java当中，线程通常都有五种状态，创建、就绪、运行、阻塞和死亡：
　　第一是创建状态:在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。
　　第二是就绪状态:当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。
                   在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。
　　第三是运行状态:线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。
　　第四是阻塞状态:线程正在运行的时候，被暂停，通常是为了等待某个事件的发生(比如说某项资源就绪)之后再继续运行。sleep，suspend，wait等方法都可以导致线程阻塞。
                   阻塞状态的线程被重新激活时，线程调度器检查它是否具有比当前运行线程更高的优先级，
                   如果有，调度器从当前运行线程中挑选一个，剥夺其运行权，选一个新的线程运行
　　第五是死亡状态:如果一个线程的run方法执行结束或者调用stop方法后，或者是因为异常而出错，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪。

2、实现并启动线程的方法：
    1、写一个类继承自Thread类，重写run方法。用start方法启动线程
    2、写一个类实现Runnable接口，实现run方法。用new Thread(Runnable target).start()方法来启动

3、多线程原理：
    只有一个CPU，要运行多个线程，调用start()就是排队，等待CPU选中，如果选了，就调用run()，在等待时可以执行其他的代码
    不需要等线程run了后再执行

4、start和run的区别
    start：用来启动线程，真正实现了多线程运行，无需等待run执行后再执行其他代码，调用start后，线程会被放到等待队列，
           等待CPU调度，不一定马上执行，线程被设置为就绪状态，通过JVM，线程会调用run，调用完后线程终止，CPU调用其他线程
    run：可以当普通方法来调用，程序还是按顺序执行，等run结束后才能执行后面的代码，没有达到多线程的目的

5、线程优先级
    每一个线程都有一个优先级，默认情况下是继承父线程的优先级，可以通过setPriority来设置线程的优先级
    当线程调度器有机会选择新的线程时，它首先选择优先级高的线程，而线程的优先级是依赖于系统的，优先级可能更高，也可能更低

6、守护线程（daemon thread）
    守护线程的作业就是辅助其他线程，比如做个计时器，当只剩下守护线程时，虚拟机就退出了，没必要继续运行程序
    比如垃圾回收线程

7、锁对象
    有两种方式：1、用synchronized关键字    2、用ReentrantLock类
    用第二种方式时，是先实例化一个ReentrantLock对象，然后lock住要锁的代码，最后再unlock
    只要一个线程有lock住代码段，其他线程都无法通过lock语句，当其他线程调用lock时，他们被阻塞，直到之前的lock有unlock
    如果是一个线程多次调用就不会阻塞，多个线程调用就会阻塞

8、条件对象
    当锁住的代码需要其他线程执行某些操作后才能继续，则需要用到条件对象
    用锁的newCondition方法取得与当前锁相关的条件对象，调用await，线程进入等待集，阻塞。
    当锁可用时，线程不能马上解除阻塞，直到另一个线程调用同一条件下的signalAll方法为止
    signalAll会激活因该条件而等待的所有线程，使线程成为可运行的，其中的一个线程将被返回，并从阻塞的地方开始执行
    这就等于之前调用await的线程寄希望于其他线程，如果没有其他线程激活，则永远不再运行，这就是死锁现象。
    如果最后一个线程再解除其他线程的阻塞状态时就await，则这个程序就被挂起了。

9、synchronized关键字
    每个对象都有内部锁和条件，使用该关键字就可以获得对象的内部锁
    修饰方法或代码块，表示给方法或代码块加锁
    用Object的wait将线程添加到等待集(阻塞)，用notifyAll/notify可以解除线程的阻塞状态

10、volatile关键字   ：不会与其他内存操作重排序
    特性： 1、使修饰的变量具有可见性   2、禁止指令重新排序
    volatile是一种比synchronized更轻量的同步机制
    如果仅仅只是想让一个变量同步，使用synchronized的开销会比较大，应该使用volatile
    一般程序都是把变量的值更新到工作内存中，然后再放到主内存中，如果使用了volatile则强制程序从主内存取对应的属性
    属性修改后也强制更新到主内存中

11、读写锁 ReentrantReadWrite
    通过锁的readLock()可以获得读锁，writeLock()可以获得写锁
    读锁是可以被多个线程进行读操作共用的锁，但会排斥所有写操作，写锁同理

12、阻塞队列
    使用队列，可以安全地从一个线程向另一个线程传递数据，相关的操作方法查API

13、Callable和FutureT
    Callable与Runnable类似，但是有返回值，只有一个方法call

14、ThreadLocal类
    是一种把变量与当前线程绑定在一起的机制，会为每个线程创建一个副本，将对象的可见范围限制在同一线程，使其变为线程级的
    每个线程内部都有一个ThreadLocalMap对象，ThreadLocal只是个入口，真正的变量都是绑定在ThreadLocalMap对象上的
    以当前线程为key，值为value，进行存储，如果没有set就进行get，是获取不到值的，而如果获取不到的时候，就会对其设置初始值
    有initialValue()方法，可以对其进行重写，在没有set就进行get时设置初始值