对象的创建

    1、对象的创建是通过new关键字来实现的

    2、当虚拟机遇到一条new指令时，会先检查这个指令的参数是否能在常量池中定位到对应类的符号引用，
       并检查对应的类是否被加载，解析，初始化过，如果没有，就先加载该类

    3、类加载检查通过后，虚拟机将为新生对象分配内存，对象内存的大小是类加载后就完全确定的

    4、内存的分配与垃圾回收器算法有关
       ①如果堆中内存是规整的，就使用“指针碰撞”的方法：把内存分为两部分：空闲和非空闲；有一个指针是分界点的指示器，
         分配内存时会把指针向空闲空间挪一段与对象大小相等的距离，对应的GC算法：Serial，ParNew等
       ②如果内存是不规整的，就使用“空闲列表”的方法：虚拟机会维护一个列表，记录哪些内存是可用的，
         分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表的记录，对应的GC算法：CMS等

    5、由于对象的创建很频繁，是线程不安全的，可能出现对象A分配内存，指针或记录还没来得及修改，对象B又同时使用了原来的指针的情况
       解决方案：
                ①对分配内存空间的动作进行同步处理，java虚拟机采用CAS配上失败重试的方式保证更新操作的原子性
                ②把内存分配的动作按照线程划分在不同的空间中进行，每个线程在堆中预先分配一小块内存，称为本地线程缓冲
                  哪个线程需要分配内存时，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定
                  虚拟机是否使用TLAB，通过设置参数设定

    6、内存分配完成后，虚拟机要将分配到的内存空间都设置为默认值，也就是类加载过程中的准备阶段，
       设置默认值是为了保证对象的实例字段在java代码中可以不赋初始值就直接使用

    7（不懂）、虚拟机要对对象进行必要设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息，
       这些信息存放在对象的对象头，根据虚拟机运行状态的不同，如是否弃用偏向锁等，对象头会有不同的设置方式

    8、此时对象的所有字段都还是默认值，需要执行了init方法后才能被初始化，对象才算完全产生出来

对象的内存布局

    对象在内存中存储的布局可以分为3块区域：对象头、实例数据和对齐填充

       1）对象头包括两部分信息：
           ①用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标记，偏向线程ID，偏向时间戳等，
             由于要存储的数据比较多，所以该区域被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的信息
             它会根据对象的状态复用自己的存储空间
           ②另一部分就是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定对象是哪个类的实例
             但是并不是所有的虚拟机实现都必须在对象数据上保留类型指针，也就是查找对象的元数据不一定要经过对象本身
             如果是一个数组，则对象头还必须有一块用于记录数组长度的数据，因为从数组元数据无法确定数组的大小

       2）实例数据部分是对象真正存储的有效信息，也就是程序中所定义的各种类型的字段内容，包括从父类继承下来的
          这部分的存储顺序会受到虚拟机分配策略参数和字段在程序中定义的顺序所影响

       3）对齐填充并不是必然存在的，也没有特别含义，仅仅起着占位符的作用，
          因为HotspotVM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，
          也就是对象的大小必须是8字节的整数倍，而对象头部分正好是8字节的倍数，
          所以当对象实例数据部分没有对齐时，就需要对齐填充来补全
