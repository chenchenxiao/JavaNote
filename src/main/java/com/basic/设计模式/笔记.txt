
三大类：
    创建型模式：
        抽象了对象实例化的过程，用来帮助创建对象的实例
    结构型模式：
        描述如何组合类和对象以获得更大的结构
    行为型模式：
        描述算法和对象职责间的分配

设计原则：设计模式就是这些设计原则上的一些具体实现
    1、找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
    2、针对接口编程，而不是针对实现编程
    3、多用组合，少用继承
    4、为了交互对象间的松耦合设计而努力
    5、类应该对扩展开放，对修改关闭（开闭原则）
    6、要依赖抽象，不要依赖具体类（依赖倒置原则）
    7、减少对象间的交互，只留下几个“密友”（最少知识原则）
           实现：1、只调用该对象本身的方法6
                 2、只调用被当作方法参数而传递进来的对象
                 3、只使用此方法创建或实例化的对象
                 4、只调用对象的足见（也就是对象所引用的对象）
    8、别调用我们，我们会调用你。
       即允许低层组件挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件
    9、一个类应该只有一个引起变化的原因（单一责任）

策略模式：
    eg: void eat(Anmail anmail)(){}
    在使用时根据所需传入不同的Anmail子类实例，同一行为有不同的实现
    优缺点：
        定义一系列算法，避免多重条件语句，更好的扩展性
        客户必须了解每种策略的不同，增加了对象的数目，只适合扁平的数据结构
    本质：
        分离算法，选择实现

观察者模式：
    在对象之间定义一对多的依赖，当一个对象改变时，依赖它的对象都会收到通知，并自动更新

装饰者模式：
    动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案

工厂方法模式：
    定义了一个创建对象的接口，但由子类决定要实例化的是哪一个，工厂方法让类把实例化推迟到子类
    使用的是继承的方式
    优缺点：
        可以在不知具体实现的情况编程，更容易扩展对象的新版本，连接平行层次
        具体产品对象和工厂方法的耦合性
    本质：
        延迟到子类来选择实现
        体现了“依赖倒置原则”


抽象工厂模式：
    提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类
    定义一个负责创建一组产品的接口，接口内的每个方法都负责创建一个具体产品
    抽象工厂的方法经常以工厂方法的方式实现
    使用的是组合的方式
    优缺点：
        分离接口和实现，使得切换产品簇变得容易
        不太容易扩展新的产品
    本质：
        选择产品簇的实现

单例模式：
    确保一个类只有一个实例，并提供一个全局访问点

命令模式：
    将“请求”封装成对象，以便使用不同的请求队列或者日志来参数化其他对象，命令模式也支持可撤销的操作
    优缺点
        更好的松散耦合，更动态的控制，能很自然的复古命令，更好的扩展性
    本质：
        封装请求

适配器模式：
    将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间

外观模式：
    提供了一个统一的接口，用来访问子系统中一群接口。外观定义了一个高层接口，让子系统更容易使用
    优缺点：
        松散耦合，简单易用，更好的划分层次
        过多的或是不合理的Facade也容易让人迷惑
    本质:
        封装调用，简化调用
    体现了“最小知识原则”

模板方法模式：
    在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些逻辑

迭代器模式：
    提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示
    优缺点：
        更好的封装性，可以以不同的遍历方式来遍历一个聚合，迭代器简化了聚合的接口
        同一个聚合上可以有多个遍历
    本质：
        控制访问聚合对象的元素
组合模式：
    允许将对象组合成树状结构来表示“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合
    优缺点：
        定义了包含基本对象和组合对象的类层次结构，统一了组合对象和叶子对象，简化了客户端调用，更容易扩展
        很难限制组合中的组件类型
    本质：
        统一叶子对象和组合对象

状态模式：
    允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类
    优缺点：
        简化应用逻辑控制，更好的分离状态和行为，更好的扩展性，显示进行状态转换
        引入太多状态类
    本质：
        根据状态来分离和选择行为


代理模式：
    为另一个对象提供一个替身或占位符以控制对这个对象的访问
    使用代表对象创建代表对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象，创建开销大的对象或需要安全控制的对象
    本质：
        控制对象访问
生成器模式：
    使一个复杂对象的构建与它的表示分离，使同样的构建过程可以创建不同的表示
    优缺点：
        松散耦合，可以很容易的改变产品的内部表示，更好的复用性
    本质：
        分离整体构建算法和部件构造

原型模式：
    优缺点：
        对客户端隐藏具体的实现类型，在运行时动态改变具体实现类型
        深度克隆方法实现会比较困难
    本质：
        生成克隆对象

中介者模式：
    优缺点：
        松散耦合，集中控制交互
        过度集中化
    本质：
        封装交互

备忘录模式：
    优缺点：
        更好的封装性，简化了原发器，窄接口和宽接口
        可能会导致高开销

享元模式：
    运用共享技术有效地支持大量细粒度的对象