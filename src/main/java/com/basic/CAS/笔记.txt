java中有两种锁：悲观锁（独占锁）和乐观锁

synchronized就是一种独占锁，会导致其他所有需要锁的线程挂起，等待持有锁的线程，而另一种更加有效的锁就是乐观锁
乐观锁就是每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功，乐观锁使用的机制就是CAS

synchronized关键字可以实现同步，但会有以下的问题
    1、在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题
    2、一个线程持有锁会导致其他所有需要此锁的线程挂起，也就是某个线程调用了某个类的同步方法后，其他要调用的线程就会被挂起
    3、如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险

CAS实现同步
    CAS有三个操作数，内存值V，预期值A，要修改的值B。仅当内存值V与预期值A相等时，将内存值V修改成B，否则什么都不做
    CAS是通过调用JNI来实现的

CAS的问题：

    1、ABA问题，也就是如果一个值从A改为B再改为A，值还是一样，实际是有改变的，但是CAS进行检查时会认为它是没有改变的
       解决思路是使用版本号，在变量前面加上版本号，每次更新变量时版本号的值加一，就会变成 1A 1B 2A
       从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。
       这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，
       并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
       关于ABA问题参考文档: http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html

    2、循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，
       pause指令有两个作用：
           第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。
           第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

    3、只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作
       但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，
       就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。
       从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。